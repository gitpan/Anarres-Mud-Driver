%{
# Use: yapp -m 'Anarres::Mud::Driver::Compiler::Parse' \
# 		-o Parse.pm Parse.yp
# to generate the Parse module.
%}

%{
use strict;
use Data::Dumper;
use Anarres::Mud::Driver::Compiler::Lex qw(%TYPETAB);
use Anarres::Mud::Driver::Program::Variable;
use Anarres::Mud::Driver::Program::Method;
use Anarres::Mud::Driver::Program::Node qw(@NODETYPES);

sub PROG_INHERITS	() { 0 }
sub PROG_GLOBALS	() { 1 }
sub PROG_FUNCTIONS	() { 2 }

# This will not be on the exam.
BEGIN {
	no strict qw(refs);
	my $package = __PACKAGE__;
	foreach (@NODETYPES) {
		# print " $_";
		# We don't necessarily call all of these in the tree -
		# only the generic type (nonsemantic) nodes.
		my $subname = "n_" . lc $_;
		eval qq{
			sub $subname {
				new Anarres::Mud::Driver::Program::Node::$_(\@_);
			}
		}; die $@ if $@;
	}
	# print "\n";
}

%}

%token L_MAP_START L_MAP_END
%token L_ARRAY_START L_ARRAY_END
%token L_FUNCTION_START L_FUNCTION_END
%token L_PARAMETER L_IDENTIFIER L_NIL L_STRING L_INTEGER
%token L_BASIC_TYPE L_TYPE_MODIFIER

%token L_INHERIT L_COLONCOLON
%token L_IF L_DO L_WHILE L_FOR L_FOREACH L_IN L_RLIMITS
%token L_TRY L_CATCH
%token L_SWITCH L_CASE L_BREAK
%token L_CONTINUE L_RETURN L_ELSE

%token L_VOID L_ELLIPSIS

%nonassoc LOWER_THAN_ELSE
%nonassoc L_ELSE

# Strictly these can be %token
%nonassoc L_PLUS_EQ L_MINUS_EQ L_DIV_EQ L_TIMES_EQ
%nonassoc L_MOD_EQ L_AND_EQ L_OR_EQ L_XOR_EQ L_DOT_EQ

# %left CONST
%right '?'
%left L_LOR
%left L_LAND
%left '|'
%left '^'
%left '&'
%left L_EQ L_NE
%left L_GE L_LE '<' '>'
%left L_LSH L_RSH
%left '.'
%left '+' '-'
%left '*' '%' '/'
%right '!' '~'
%nonassoc L_INC L_DEC

%start all

%%

all
		: program				# default
		{
			undef;
		}
	;

program
		: program definition
		{
			# push(@{$_[1]}, $_[2]); $_[1];
			undef;
		}
		|						# empty
		{
			undef;
		}
	;

definition
		: inheritance
		{
			undef;
		}
		| global_decl
		{
			undef;
		}
		| function
		{
			undef;
		}
		| prototype
		{
			undef;
		}
	;

inheritance
		: L_INHERIT string_const ';'
		{
			$_[0]->YYData->{Program}->inherit($_[2]);
		}
	;

identifier
		: L_IDENTIFIER			# default
	;

	# Changing this will cause function_prologue to change
	# XXX Merge this into function_prologue to save time/RAM
function_declarator
		: star_list identifier '(' arguments ')'
		{
			return [ $_[1], $_[2], $_[4] ];
		}
	;

	# Changing this will cause local_decl and global_decl to be changed
variable_declarator
		: star_list identifier
		{
			return [ $_[1], $_[2] ];
		}
	;

variable_declarator_list
		: variable_declarator
		{
			return [ $_[1] ];
		}
		| variable_declarator_list ',' variable_declarator
		{
			push(@{$_[1]}, $_[3]); $_[1];
		}
	;

variable_declarator_init
		: variable_declarator
		{
			push(@{$_[1]}, undef); $_[1];
		}
		| variable_declarator '=' exp
		{
			push(@{$_[1]}, $_[3]); $_[1];
		}
	;

variable_declarator_list_init
		: variable_declarator_init
		{
			return [ $_[1] ];
		}
		| variable_declarator_list_init ',' variable_declarator_init
		{
			push(@{$_[1]}, $_[3]); $_[1];
		}
	;

	# This isn't quite the way it ought to be done since it doesn't
	# let me mix declarator types between function and data.
function_prologue
		: type_modifier_list type_specifier function_declarator
		{
			my $type = $_[2];
			$type = $type->pointer($_[3]->[0]) if $_[3]->[0];
			my $method = new Anarres::Mud::Driver::Program::Method(
					Type	=> $type,
					Name	=> $_[3]->[1],
					Args	=> $_[3]->[2],
						);
			$_[0]->YYData->{Program}->method($method, $_[1]);
			return $method;
		}
	;

prototype
		: function_prologue ';'	# default
	;

function
		: function_prologue block
		{
			# print "Parse code is $_[2]\n";
			$_[1]->code($_[2]);	# Add code to the method
		}
	;

block
		: '{'
			{
				my $program = $_[0]->YYData->{Program};
				# $program->scope_start;
				$program;		# Into $_[2]
			}
		local_decls
			{
				foreach (@{$_[3]}) {
					# $_[2]->local($_);
				}
			}
		statement_list '}'
		{
			# $_[2]->scope_end;
			return n_block($_[3], $_[5]);
		}
	;

statement_list
		:						# empty
		{
			return [ ];
		}
		| statement_list statement
		{
			push(@{$_[1]}, $_[2]) if $_[2]; $_[1];
		}
		| error ';'
		{
			push(@{$_[1]}, 'ERROR'); $_[1];
		}
	;

statement
		: list_exp ';'
			{ n_stmtexp $_[1] }
		| block					# default
		| L_IF '(' nv_list_exp ')' statement opt_else
			{ n_stmtif $_[3], $_[5], $_[6] }
		| L_DO
			{
				# XXX Set loop context
			}
			statement
			{
				# XXX Unset loop context
			}
			L_WHILE '(' nv_list_exp ')' ';'
			{ n_stmtdo $_[7], $_[3] }
		| L_WHILE '(' nv_list_exp ')'
			{
				# XXX Set loop context
			}
			statement
			{ n_stmtwhile $_[3], $_[6] }
		| L_FOR '(' opt_list_exp ';'
					opt_nv_list_exp ';'
					opt_list_exp ')'
			{
				# XXX Set loop context
			}
			statement
			{ n_stmtfor $_[3], $_[5], $_[7], $_[10]; }
		| L_FOREACH '(' lvalue L_IN exp ')'
			{
				# XXX Set loop context
			}
			statement
			{ n_stmtforeach $_[3], $_[5], $_[8]; }
		| L_RLIMITS '(' nv_list_exp ';' nv_list_exp ')' statement
			{ n_stmtrlimits $_[3], $_[5], $_[7] }	# stack, eval
		| L_TRY block L_CATCH '(' lvalue ')' block
			{ n_stmttry $_[2], $_[5], $_[7] }
		# This for MudOS!
		| L_CATCH block
			{ n_stmtcatch $_[2] }
		# switch, case
		| L_SWITCH '(' nv_list_exp ')'
			{
				# XXX Set switch context
			}
			block
			{ n_stmtswitch $_[3], $_[6]; }
		| L_CASE exp ':'
			{ n_stmtcase $_[2], undef }
		| L_CASE exp L_RANGE exp ':'
			{ n_stmtcase $_[2], $_[4] }
		| L_DEFAULT ':'
			{ n_stmtdefault }
		| L_BREAK ';'
			{ n_stmtbreak }
		| L_CONTINUE ';'
			{ n_stmtcontinue }
		| L_RETURN opt_nv_list_exp ';'
			{ n_stmtreturn $_[2] }
		| ';'
			{ n_stmtnull; }
	;

opt_else
		: %prec LOWER_THAN_ELSE	# empty
		{
			return undef;
		}
		| L_ELSE statement
		{
			return $_[2];
		}
	;

#opt_label		# For labelled loops
#		:						# empty
#			{ undef }
#		| identifier ':'
#			{ $_[1] }
#	;



list_exp
		: exp
		{
			return $_[1];
		}
		| list_exp ',' exp
		{
			return [ 'COMMA', $_[1], $_[3] ];
		}
	;

opt_list_exp
		:						# empty
			{ n_expnull }
		| list_exp				# default
	;

nv_list_exp
		: exp					# check nonvoid
	;

opt_nv_list_exp
		:
			{ n_expnull }
		| nv_list_exp
	;

arg_list
		: exp					# check nonvoid
		{
			return [ $_[1] ];
		}
		| arg_list ',' exp		# check nonvoid
		{
			push(@{$_[1]}, $_[3]); $_[1];
		}
	;

opt_arg_list
		:						# empty
		{
			return [];
		}
		| arg_list				# default
	;

opt_arg_list_comma
		:						# empty
		{
			return [];
		}
		| arg_list				# default
		| arg_list ','			# default
	;

assoc_exp
		: exp ':' exp			# check nonvoid
		{
			return [ $_[1], $_[3] ];
		}
	;

	# We save on memory by building a single flat list.
assoc_arg_list
		: assoc_exp
		{
			return $_[1];
		}
		| assoc_arg_list ',' assoc_exp
		{
			push(@{$_[1]}, @{$_[3]}); $_[1];
		}
	;

opt_assoc_arg_list_comma
		:						# empty
			{ [ ] }
		| assoc_arg_list		# default
		| assoc_arg_list ','	# default
	;

function_name					# use $_[0]->YYError
		: identifier			# check exists
		{
			# print "Finding function name $_[1]\n";
			$_[0]->YYData->{Program}->method($_[1]);
		}
		| L_COLONCOLON identifier
		{
			# inherited lfun
			# return [ 'inherited_function', $_[2], undef ];
			$_[0]->YYData->{Program}->method('::' . $_[2]);
		}
		| identifier L_COLONCOLON identifier
		{
			# specified inherited lfun
			# return [ 'inherited_function', $_[3], $_[1] ];
			$_[0]->YYData->{Program}->method($_[1] . '::' . $_[3]);
		}
		| L_EFUN L_COLONCOLON identifier
		{
			# treat this as an inherited function
			$_[0]->YYData->{Program}->method('::' . $_[3]);
		}
	;

	# Put 'error' here? Invalid lvalue warning?
lvalue
		: array_exp				# check
	;

	# XXX This is Wrong, since we evaluate the lvalue twice...
	# and the lvalue may have a side effect, e.g. a[i++] += 5;
exp
		: cond_exp				# default
		| lvalue '=' exp
			{ n_assign $_[1], $_[3] }
		| lvalue L_PLUS_EQ exp
			{ n_assign($_[1], n_add($_[1], $_[3])) }
		| lvalue L_MINUS_EQ exp
			{ n_assign($_[1], n_sub($_[1], $_[3])) }
		| lvalue L_DIV_EQ exp
			{ n_assign($_[1], n_div($_[1], $_[3])) }
		| lvalue L_TIMES_EQ exp
			{ n_assign($_[1], n_mul($_[1], $_[3])) }
		| lvalue L_MOD_EQ exp
			{ n_assign($_[1], n_mod($_[1], $_[3])) }
		| lvalue L_AND_EQ exp
			{ n_assign($_[1], n_and($_[1], $_[3])) }
		| lvalue L_OR_EQ exp
			{ n_assign($_[1], n_or($_[1], $_[3])) }
		| lvalue L_XOR_EQ exp
			{ n_assign($_[1], n_xor($_[1], $_[3])) }
		| lvalue L_DOT_EQ exp
			{ n_assign($_[1], n_stradd($_[1], $_[3])) }	# XXX n_dot ?
	;

cond_exp
		: logical_exp			# default
		| logical_exp '?' list_exp ':' cond_exp %prec '?'
			{ n_expcond $_[1], $_[3], $_[5] }
	;

logical_exp
		: compare_exp			# default
		| logical_exp L_LOR logical_exp		{ n_logor	$_[1], $_[3] }
		| logical_exp L_LAND logical_exp	{ n_logand	$_[1], $_[3] }
		| logical_exp '|' logical_exp		{ n_or		$_[1], $_[3] }
		| logical_exp '^' logical_exp		{ n_xor		$_[1], $_[3] }
		| logical_exp '&' logical_exp		{ n_and		$_[1], $_[3] }
	;

compare_exp
		: arith_exp				# default
		| compare_exp L_EQ compare_exp		{ n_eq $_[1], $_[3] }
		| compare_exp L_NE compare_exp		{ n_ne $_[1], $_[3] }
		| compare_exp '<' compare_exp		{ n_lt $_[1], $_[3] }
		| compare_exp '>' compare_exp		{ n_gt $_[1], $_[3] }
		| compare_exp L_LE compare_exp		{ n_le $_[1], $_[3] }
		| compare_exp L_GE compare_exp		{ n_ge $_[1], $_[3] }
	;

arith_exp
		: prefix_exp			# default
		| arith_exp L_LSH arith_exp			{ n_lsh $_[1], $_[3] }
		| arith_exp L_RSH arith_exp			{ n_rsh $_[1], $_[3] }
		| arith_exp '.' arith_exp			{ n_stradd $_[1], $_[3] }
		| arith_exp '+' arith_exp			{ n_add $_[1], $_[3] }
		| arith_exp '-' arith_exp			{ n_sub $_[1], $_[3] }
		| arith_exp '*' arith_exp			{ n_mul $_[1], $_[3] }
		| arith_exp '/' arith_exp			{ n_div $_[1], $_[3] }
		| arith_exp '%' arith_exp			{ n_mod $_[1], $_[3] }
	;

prefix_exp
		: postfix_exp			# default
		| L_INC prefix_exp					{ n_preinc $_[2] }
		| L_DEC prefix_exp					{ n_predec $_[2] }
		| '!' prefix_exp					{ n_unot $_[2] }
		| '~' prefix_exp					{ n_tilde $_[2] }
		| '+' prefix_exp					{ n_plus $_[2] }
		| '-' prefix_exp					{ n_minus $_[2] }
	;

postfix_exp
		: array_exp				# default
		| postfix_exp L_INC					{ n_postinc $_[1] }
		| postfix_exp L_DEC					{ n_postdec $_[1] }
	;

array_exp
		: basic_exp				# default
		| array_exp '[' opt_endrange nv_list_exp ']'
		{
			n_index $_[1], $_[4];
		}
		| array_exp '[' opt_endrange nv_list_exp
							L_RANGE
						opt_endrange nv_list_exp ']'
		{
			# XXX Correct for ends of range
			n_range $_[1], $_[4], $_[7];
		}
	;

opt_endrange
		:						# empty
		{
			undef
		}
		| '<'
		{
			1
		}
	;

basic_exp
		: L_NIL					{ n_nil }
		| string				{ n_string $_[1] }
		| integer				{ n_integer $_[1] }
		| array					{ n_array @{ $_[1] } }	# XXX Naughty
		| mapping				{ n_mapping @{ $_[1] } }
		| closure				{ n_closure $_[1] }
		| identifier			{ n_variable $_[1] }
		| L_PARAMETER
		{
			# XXX Check in closure context?
			n_parameter $_[1]
		}
		| '$' '(' identifier ')'
		{
			# XXX A variable by value... closures only
			n_variable $_[3]
		}
		| '(' list_exp ')'		{ $_[2] }
		| function_name '(' opt_arg_list ')'
		{
			n_funcall $_[1], @{ $_[3] };
		}
		| L_SSCANF '(' exp lvalue_list ')'
		{
			n_sscanf $_[3], @{ $_[4] };		# XXX Expand later
		}
		| L_CATCH '(' list_exp ')'
		{
			n_catch $_[3];
		}
		| array_exp L_ARROW identifier '(' opt_arg_list ')'
		{
			n_callother $_[1], $_[3], @{ $_[5] };
		}
	;

lvalue_list
		:						# empty
		{
			[]
		}
		| lvalue_list ',' lvalue
		{
			push(@{$_[1]}, $_[3]); $_[1];
		}
	;









global_decl
		: type_modifier_list type_specifier variable_declarator_list ';'
		{
			foreach (@{$_[3]}) {
				my $type = $_[2];
				$type = $type->pointer($_->[0]) if $_->[0];
				my $var = new Anarres::Mud::Driver::Program::Variable(
								Type	=> $type,
								Name	=> $_->[1],
									);
				$_[0]->YYData->{Program}->global($var, $_[1]);
			}
			return undef;
		}
	;

local_decls
		:						# empty
		{
			return [];
		}
		| local_decls local_decl
		{
			push(@{$_[1]}, @{$_[2]}); $_[1];
		}
	;

local_decl
		: type_specifier variable_declarator_list_init ';'
		{
			my @out = ();
			foreach (@{$_[2]}) {
				my $type = $_[1];
				$type = $type->pointer($_->[0]) if $_->[0];
				my $var = new Anarres::Mud::Driver::Program::Variable(
								Type	=> $type,
								Name	=> $_->[1],
									);
				# XXX Deal with the init in $_->[2]
				push(@out, $var);
			}
			return \@out;
		}
	;

arguments
		:						# empty
			{ return []; }
		| L_VOID
			{ return []; }
		| argument_list			# default	
		| argument_list L_ELLIPSIS
								# default
	;

argument_list
		: argument
		{
			return [ $_[1] ];
		}
		| argument_list ',' argument
		{
			push(@{$_[1]}, $_[3]); $_[1];
		}
	;

argument
		: type_specifier variable_declarator
		{
			my $type = $_[1];
			$type = $type->pointer($_[2]->[0]) if $_[2]->[0];
			return new Anarres::Mud::Driver::Program::Variable(
							Type	=> $type,
							Name	=> $_[2]->[1],
								);
		}
	;

type_modifier_list
		:						# empty
		{ 
			return 0;
		}
		| L_TYPE_MODIFIER type_modifier_list
		{
			# XXX Check for multiple access modifiers
			return $_[1] | $_[2];
		}
	;

type_specifier
		: L_BASIC_TYPE			# default
		| L_VOID				# default
	;

	# Check for overflows
star_list
		:						# empty
		{
			return 0;
		}
		| star_list '*'
		{
			# XXX Check for too deep.
			return $_[1] + 1;
		}
		| star_list '#'
		{
			# A mapping (hash!)
			# We could "#define mapping mixed #" for compatability.
			# XXX This is wrong. It doesn't preserve ordering.
			return $_[1] + 65536;
		}
	;






string_const
		: string				# default
		| string_const '.' string_const		{ return $_[1] . $_[3] }
		| string_const '+' string_const		{ return $_[1] . $_[3] }
		| integer							{ return "$_[1]" }
	;

string
		: L_STRING				# default
#		| string '.' L_STRING %prec CONST	{ return $_[1] . $_[3] }
#		| string '+' L_STRING %prec CONST	{ return $_[1] . $_[3] }
		| string L_STRING					{ return $_[1] . $_[2] }
#		| integer							{ return "$_[1]" } # XXX ?
	;

integer	: L_INTEGER				{ 0 + $_[1] }
		| L_HEXINTEGER			{ hex($_[1]) }
		| L_CHARACTER			{ 0 + $_[1] }
#		| integer '|' integer	{ return $_[1] | $_[2] }
#		| integer '^' integer	{ return $_[1] ^ $_[2] }
#		| integer '&' integer	{ return $_[1] & $_[2] }
#		| integer '+' integer	{ return $_[1] + $_[2] }
#		| integer '-' integer	{ return $_[1] - $_[2] }
#		| integer '*' integer	{ return $_[1] * $_[2] }
#		| '-' integer			{ return - $_[2] }
#		| '!' integer			{ return ! $_[2] }
#		| '~' integer			{ return ~ $_[2] }
	;

array
		: L_ARRAY_START opt_arg_list_comma L_ARRAY_END
			{ $_[2] }
	;

mapping
		: L_MAP_START opt_assoc_arg_list_comma L_MAP_END
			{ $_[2] }
	;

	# XXX We also need to support things like (: foo :)
closure
		: L_FUNCTION_START list_exp L_FUNCTION_END
			{ $_[2] }
	;

%%

sub yyerror {
	my ($self) = @_;

	my $currtok = $_[0]->YYCurtok;
	my $lexer = $self->YYData->{Lexer};

	if ($currtok eq 'L_MAP_END') {
		# print "Convert L_MAP_END to ']' ')'\n";
		$_[0]->YYCurtok(']');
		$_[0]->YYCurval(']');
		# $lexer->unput(')');
		$lexer->rewind(1);	# length ')'
		$_[0]->YYErrok;
		return undef;
	}

	my $at = $lexer->at;
	my $tok = $self->YYCurtok;
	my $val = $self->YYCurval;
	$val = defined $val ? $val : "[no token value]";
	my $expect = "'" . join("', '", sort $self->YYExpect) . "'";

	print "Parse error at $at\n" .
		"Got $tok ($val)\n" .
		"Expected one of $expect\n";

	die "Byebye.";
}

sub yyparse {
	my ($self, $prog, $lexer) = @_;

	$self->YYData->{Lexer} = $lexer;
	$self->YYData->{Program} = $prog;

	$self->YYParse(
					# yylex	=> $lexer->can('lex_debug'),
					# yylex	=> $lexer->can('lex'),
					yylex	=> sub { $lexer->lex },
					yyerror	=> \&yyerror,
						);
}

1;
