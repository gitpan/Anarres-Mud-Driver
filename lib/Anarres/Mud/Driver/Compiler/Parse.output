Conflicts:
----------
Conflict in state 36 between rule 164 and token '.' resolved as reduce.
Conflict in state 36 between rule 164 and token '+' resolved as reduce.
Conflict in state 37 between rule 163 and token '.' resolved as reduce.
Conflict in state 37 between rule 163 and token '+' resolved as shift.
Conflict in state 201 between rule 106 and token L_RSH resolved as reduce.
Conflict in state 201 between rule 106 and token '%' resolved as shift.
Conflict in state 201 between rule 106 and token '*' resolved as shift.
Conflict in state 201 between rule 106 and token '+' resolved as shift.
Conflict in state 201 between rule 106 and token L_LSH resolved as reduce.
Conflict in state 201 between rule 106 and token '-' resolved as shift.
Conflict in state 201 between rule 106 and token '.' resolved as shift.
Conflict in state 201 between rule 106 and token '/' resolved as shift.
Conflict in state 202 between rule 110 and token L_RSH resolved as reduce.
Conflict in state 202 between rule 110 and token '%' resolved as reduce.
Conflict in state 202 between rule 110 and token '*' resolved as reduce.
Conflict in state 202 between rule 110 and token '+' resolved as reduce.
Conflict in state 202 between rule 110 and token L_LSH resolved as reduce.
Conflict in state 202 between rule 110 and token '-' resolved as reduce.
Conflict in state 202 between rule 110 and token '.' resolved as reduce.
Conflict in state 202 between rule 110 and token '/' resolved as reduce.
Conflict in state 203 between rule 107 and token L_RSH resolved as reduce.
Conflict in state 203 between rule 107 and token '%' resolved as shift.
Conflict in state 203 between rule 107 and token '*' resolved as shift.
Conflict in state 203 between rule 107 and token '+' resolved as shift.
Conflict in state 203 between rule 107 and token L_LSH resolved as reduce.
Conflict in state 203 between rule 107 and token '-' resolved as shift.
Conflict in state 203 between rule 107 and token '.' resolved as reduce.
Conflict in state 203 between rule 107 and token '/' resolved as shift.
Conflict in state 204 between rule 112 and token L_RSH resolved as reduce.
Conflict in state 204 between rule 112 and token '%' resolved as reduce.
Conflict in state 204 between rule 112 and token '*' resolved as reduce.
Conflict in state 204 between rule 112 and token '+' resolved as reduce.
Conflict in state 204 between rule 112 and token L_LSH resolved as reduce.
Conflict in state 204 between rule 112 and token '-' resolved as reduce.
Conflict in state 204 between rule 112 and token '.' resolved as reduce.
Conflict in state 204 between rule 112 and token '/' resolved as reduce.
Conflict in state 205 between rule 108 and token L_RSH resolved as reduce.
Conflict in state 205 between rule 108 and token '%' resolved as shift.
Conflict in state 205 between rule 108 and token '*' resolved as shift.
Conflict in state 205 between rule 108 and token '+' resolved as reduce.
Conflict in state 205 between rule 108 and token L_LSH resolved as reduce.
Conflict in state 205 between rule 108 and token '-' resolved as reduce.
Conflict in state 205 between rule 108 and token '.' resolved as reduce.
Conflict in state 205 between rule 108 and token '/' resolved as shift.
Conflict in state 206 between rule 105 and token L_RSH resolved as reduce.
Conflict in state 206 between rule 105 and token '%' resolved as shift.
Conflict in state 206 between rule 105 and token '*' resolved as shift.
Conflict in state 206 between rule 105 and token '+' resolved as shift.
Conflict in state 206 between rule 105 and token L_LSH resolved as reduce.
Conflict in state 206 between rule 105 and token '-' resolved as shift.
Conflict in state 206 between rule 105 and token '.' resolved as shift.
Conflict in state 206 between rule 105 and token '/' resolved as shift.
Conflict in state 207 between rule 109 and token L_RSH resolved as reduce.
Conflict in state 207 between rule 109 and token '%' resolved as shift.
Conflict in state 207 between rule 109 and token '*' resolved as shift.
Conflict in state 207 between rule 109 and token '+' resolved as reduce.
Conflict in state 207 between rule 109 and token L_LSH resolved as reduce.
Conflict in state 207 between rule 109 and token '-' resolved as reduce.
Conflict in state 207 between rule 109 and token '.' resolved as reduce.
Conflict in state 207 between rule 109 and token '/' resolved as shift.
Conflict in state 208 between rule 111 and token L_RSH resolved as reduce.
Conflict in state 208 between rule 111 and token '%' resolved as reduce.
Conflict in state 208 between rule 111 and token '*' resolved as reduce.
Conflict in state 208 between rule 111 and token '+' resolved as reduce.
Conflict in state 208 between rule 111 and token L_LSH resolved as reduce.
Conflict in state 208 between rule 111 and token '-' resolved as reduce.
Conflict in state 208 between rule 111 and token '.' resolved as reduce.
Conflict in state 208 between rule 111 and token '/' resolved as reduce.
Conflict in state 237 between rule 96 and token L_LAND resolved as reduce.
Conflict in state 237 between rule 96 and token '&' resolved as reduce.
Conflict in state 237 between rule 96 and token L_LOR resolved as reduce.
Conflict in state 237 between rule 96 and token '|' resolved as reduce.
Conflict in state 237 between rule 96 and token '^' resolved as reduce.
Conflict in state 239 between rule 93 and token L_LAND resolved as reduce.
Conflict in state 239 between rule 93 and token '&' resolved as shift.
Conflict in state 239 between rule 93 and token L_LOR resolved as reduce.
Conflict in state 239 between rule 93 and token '|' resolved as shift.
Conflict in state 239 between rule 93 and token '^' resolved as shift.
Conflict in state 240 between rule 92 and token L_LAND resolved as shift.
Conflict in state 240 between rule 92 and token '&' resolved as shift.
Conflict in state 240 between rule 92 and token L_LOR resolved as reduce.
Conflict in state 240 between rule 92 and token '|' resolved as shift.
Conflict in state 240 between rule 92 and token '^' resolved as shift.
Conflict in state 241 between rule 94 and token L_LAND resolved as reduce.
Conflict in state 241 between rule 94 and token '&' resolved as shift.
Conflict in state 241 between rule 94 and token L_LOR resolved as reduce.
Conflict in state 241 between rule 94 and token '|' resolved as reduce.
Conflict in state 241 between rule 94 and token '^' resolved as shift.
Conflict in state 242 between rule 95 and token L_LAND resolved as reduce.
Conflict in state 242 between rule 95 and token '&' resolved as shift.
Conflict in state 242 between rule 95 and token L_LOR resolved as reduce.
Conflict in state 242 between rule 95 and token '|' resolved as reduce.
Conflict in state 242 between rule 95 and token '^' resolved as reduce.
Conflict in state 243 between rule 102 and token L_GE resolved as reduce.
Conflict in state 243 between rule 102 and token L_EQ resolved as reduce.
Conflict in state 243 between rule 102 and token L_LE resolved as reduce.
Conflict in state 243 between rule 102 and token L_NE resolved as reduce.
Conflict in state 243 between rule 102 and token '<' resolved as reduce.
Conflict in state 243 between rule 102 and token '>' resolved as reduce.
Conflict in state 244 between rule 99 and token L_GE resolved as shift.
Conflict in state 244 between rule 99 and token L_EQ resolved as reduce.
Conflict in state 244 between rule 99 and token L_LE resolved as shift.
Conflict in state 244 between rule 99 and token L_NE resolved as reduce.
Conflict in state 244 between rule 99 and token '<' resolved as shift.
Conflict in state 244 between rule 99 and token '>' resolved as shift.
Conflict in state 245 between rule 103 and token L_GE resolved as reduce.
Conflict in state 245 between rule 103 and token L_EQ resolved as reduce.
Conflict in state 245 between rule 103 and token L_LE resolved as reduce.
Conflict in state 245 between rule 103 and token L_NE resolved as reduce.
Conflict in state 245 between rule 103 and token '<' resolved as reduce.
Conflict in state 245 between rule 103 and token '>' resolved as reduce.
Conflict in state 246 between rule 98 and token L_GE resolved as shift.
Conflict in state 246 between rule 98 and token L_EQ resolved as reduce.
Conflict in state 246 between rule 98 and token L_LE resolved as shift.
Conflict in state 246 between rule 98 and token L_NE resolved as reduce.
Conflict in state 246 between rule 98 and token '<' resolved as shift.
Conflict in state 246 between rule 98 and token '>' resolved as shift.
Conflict in state 247 between rule 100 and token L_GE resolved as reduce.
Conflict in state 247 between rule 100 and token L_EQ resolved as reduce.
Conflict in state 247 between rule 100 and token L_LE resolved as reduce.
Conflict in state 247 between rule 100 and token L_NE resolved as reduce.
Conflict in state 247 between rule 100 and token '<' resolved as reduce.
Conflict in state 247 between rule 100 and token '>' resolved as reduce.
Conflict in state 248 between rule 101 and token L_GE resolved as reduce.
Conflict in state 248 between rule 101 and token L_EQ resolved as reduce.
Conflict in state 248 between rule 101 and token L_LE resolved as reduce.
Conflict in state 248 between rule 101 and token L_NE resolved as reduce.
Conflict in state 248 between rule 101 and token '<' resolved as reduce.
Conflict in state 248 between rule 101 and token '>' resolved as reduce.
Conflict in state 294 between rule 51 and token L_ELSE resolved as shift.

Rules:
------
0:	$start -> all $end
1:	all -> program
2:	program -> program definition
3:	program -> /* empty */
4:	definition -> inheritance
5:	definition -> global_decl
6:	definition -> function
7:	definition -> prototype
8:	inheritance -> L_INHERIT string_const ';'
9:	identifier -> L_IDENTIFIER
10:	function_declarator -> star_list identifier '(' arguments ')'
11:	variable_declarator -> star_list identifier
12:	variable_declarator_list -> variable_declarator
13:	variable_declarator_list -> variable_declarator_list ',' variable_declarator
14:	variable_declarator_init -> variable_declarator
15:	variable_declarator_init -> variable_declarator '=' exp
16:	variable_declarator_list_init -> variable_declarator_init
17:	variable_declarator_list_init -> variable_declarator_list_init ',' variable_declarator_init
18:	function_prologue -> type_modifier_list type_specifier function_declarator
19:	prototype -> function_prologue ';'
20:	function -> function_prologue block
21:	@1-1 -> /* empty */
22:	@2-3 -> /* empty */
23:	block -> '{' @1-1 local_decls @2-3 statement_list '}'
24:	statement_list -> /* empty */
25:	statement_list -> statement_list statement
26:	statement_list -> error ';'
27:	statement -> list_exp ';'
28:	statement -> block
29:	statement -> L_IF '(' nv_list_exp ')' statement opt_else
30:	@3-1 -> /* empty */
31:	@4-3 -> /* empty */
32:	statement -> L_DO @3-1 statement @4-3 L_WHILE '(' nv_list_exp ')' ';'
33:	@5-4 -> /* empty */
34:	statement -> L_WHILE '(' nv_list_exp ')' @5-4 statement
35:	@6-8 -> /* empty */
36:	statement -> L_FOR '(' opt_list_exp ';' opt_nv_list_exp ';' opt_list_exp ')' @6-8 statement
37:	@7-6 -> /* empty */
38:	statement -> L_FOREACH '(' lvalue L_IN exp ')' @7-6 statement
39:	statement -> L_RLIMITS '(' nv_list_exp ';' nv_list_exp ')' statement
40:	statement -> L_TRY block L_CATCH '(' lvalue ')' block
41:	statement -> L_CATCH block
42:	@8-4 -> /* empty */
43:	statement -> L_SWITCH '(' nv_list_exp ')' @8-4 block
44:	statement -> L_CASE exp ':'
45:	statement -> L_CASE exp L_RANGE exp ':'
46:	statement -> L_DEFAULT ':'
47:	statement -> L_BREAK ';'
48:	statement -> L_CONTINUE ';'
49:	statement -> L_RETURN opt_nv_list_exp ';'
50:	statement -> ';'
51:	opt_else -> /* empty */
52:	opt_else -> L_ELSE statement
53:	list_exp -> exp
54:	list_exp -> list_exp ',' exp
55:	opt_list_exp -> /* empty */
56:	opt_list_exp -> list_exp
57:	nv_list_exp -> exp
58:	opt_nv_list_exp -> /* empty */
59:	opt_nv_list_exp -> nv_list_exp
60:	arg_list -> exp
61:	arg_list -> arg_list ',' exp
62:	opt_arg_list -> /* empty */
63:	opt_arg_list -> arg_list
64:	opt_arg_list_comma -> /* empty */
65:	opt_arg_list_comma -> arg_list
66:	opt_arg_list_comma -> arg_list ','
67:	assoc_exp -> exp ':' exp
68:	assoc_arg_list -> assoc_exp
69:	assoc_arg_list -> assoc_arg_list ',' assoc_exp
70:	opt_assoc_arg_list_comma -> /* empty */
71:	opt_assoc_arg_list_comma -> assoc_arg_list
72:	opt_assoc_arg_list_comma -> assoc_arg_list ','
73:	function_name -> identifier
74:	function_name -> L_COLONCOLON identifier
75:	function_name -> identifier L_COLONCOLON identifier
76:	function_name -> L_EFUN L_COLONCOLON identifier
77:	lvalue -> array_exp
78:	exp -> cond_exp
79:	exp -> lvalue '=' exp
80:	exp -> lvalue L_PLUS_EQ exp
81:	exp -> lvalue L_MINUS_EQ exp
82:	exp -> lvalue L_DIV_EQ exp
83:	exp -> lvalue L_TIMES_EQ exp
84:	exp -> lvalue L_MOD_EQ exp
85:	exp -> lvalue L_AND_EQ exp
86:	exp -> lvalue L_OR_EQ exp
87:	exp -> lvalue L_XOR_EQ exp
88:	exp -> lvalue L_DOT_EQ exp
89:	cond_exp -> logical_exp
90:	cond_exp -> logical_exp '?' list_exp ':' cond_exp
91:	logical_exp -> compare_exp
92:	logical_exp -> logical_exp L_LOR logical_exp
93:	logical_exp -> logical_exp L_LAND logical_exp
94:	logical_exp -> logical_exp '|' logical_exp
95:	logical_exp -> logical_exp '^' logical_exp
96:	logical_exp -> logical_exp '&' logical_exp
97:	compare_exp -> arith_exp
98:	compare_exp -> compare_exp L_EQ compare_exp
99:	compare_exp -> compare_exp L_NE compare_exp
100:	compare_exp -> compare_exp '<' compare_exp
101:	compare_exp -> compare_exp '>' compare_exp
102:	compare_exp -> compare_exp L_LE compare_exp
103:	compare_exp -> compare_exp L_GE compare_exp
104:	arith_exp -> prefix_exp
105:	arith_exp -> arith_exp L_LSH arith_exp
106:	arith_exp -> arith_exp L_RSH arith_exp
107:	arith_exp -> arith_exp '.' arith_exp
108:	arith_exp -> arith_exp '+' arith_exp
109:	arith_exp -> arith_exp '-' arith_exp
110:	arith_exp -> arith_exp '*' arith_exp
111:	arith_exp -> arith_exp '/' arith_exp
112:	arith_exp -> arith_exp '%' arith_exp
113:	prefix_exp -> postfix_exp
114:	prefix_exp -> L_INC prefix_exp
115:	prefix_exp -> L_DEC prefix_exp
116:	prefix_exp -> '!' prefix_exp
117:	prefix_exp -> '~' prefix_exp
118:	prefix_exp -> '+' prefix_exp
119:	prefix_exp -> '-' prefix_exp
120:	postfix_exp -> array_exp
121:	postfix_exp -> postfix_exp L_INC
122:	postfix_exp -> postfix_exp L_DEC
123:	array_exp -> basic_exp
124:	array_exp -> array_exp '[' opt_endrange nv_list_exp ']'
125:	array_exp -> array_exp '[' opt_endrange nv_list_exp L_RANGE opt_endrange nv_list_exp ']'
126:	opt_endrange -> /* empty */
127:	opt_endrange -> '<'
128:	basic_exp -> L_NIL
129:	basic_exp -> string
130:	basic_exp -> integer
131:	basic_exp -> array
132:	basic_exp -> mapping
133:	basic_exp -> closure
134:	basic_exp -> identifier
135:	basic_exp -> L_PARAMETER
136:	basic_exp -> '$' '(' identifier ')'
137:	basic_exp -> '(' list_exp ')'
138:	basic_exp -> function_name '(' opt_arg_list ')'
139:	basic_exp -> L_SSCANF '(' exp lvalue_list ')'
140:	basic_exp -> L_CATCH '(' list_exp ')'
141:	basic_exp -> array_exp L_ARROW identifier '(' opt_arg_list ')'
142:	lvalue_list -> /* empty */
143:	lvalue_list -> lvalue_list ',' lvalue
144:	global_decl -> type_modifier_list type_specifier variable_declarator_list ';'
145:	local_decls -> /* empty */
146:	local_decls -> local_decls local_decl
147:	local_decl -> type_specifier variable_declarator_list_init ';'
148:	arguments -> /* empty */
149:	arguments -> L_VOID
150:	arguments -> argument_list
151:	arguments -> argument_list L_ELLIPSIS
152:	argument_list -> argument
153:	argument_list -> argument_list ',' argument
154:	argument -> type_specifier variable_declarator
155:	type_modifier_list -> /* empty */
156:	type_modifier_list -> L_TYPE_MODIFIER type_modifier_list
157:	type_specifier -> L_BASIC_TYPE
158:	type_specifier -> L_VOID
159:	star_list -> /* empty */
160:	star_list -> star_list '*'
161:	star_list -> star_list '#'
162:	string_const -> string
163:	string_const -> string_const '.' string_const
164:	string_const -> string_const '+' string_const
165:	string_const -> integer
166:	string -> L_STRING
167:	string -> string L_STRING
168:	integer -> L_INTEGER
169:	integer -> L_HEXINTEGER
170:	integer -> L_CHARACTER
171:	array -> L_ARRAY_START opt_arg_list_comma L_ARRAY_END
172:	mapping -> L_MAP_START opt_assoc_arg_list_comma L_MAP_END
173:	closure -> L_FUNCTION_START list_exp L_FUNCTION_END

States:
-------
State 0:

	$start -> . all $end	(Rule 0)

	$default	reduce using rule 3 (program)

	all	go to state 1
	program	go to state 2

State 1:

	$start -> all . $end	(Rule 0)

	$end	shift, and go to state 3

State 2:

	all -> program .	(Rule 1)
	program -> program . definition	(Rule 2)

	L_INHERIT	shift, and go to state 4
	L_TYPE_MODIFIER	shift, and go to state 7

	$end	reduce using rule 1 (all)
	$default	reduce using rule 155 (type_modifier_list)

	function	go to state 8
	type_modifier_list	go to state 10
	global_decl	go to state 9
	prototype	go to state 11
	inheritance	go to state 5
	definition	go to state 12
	function_prologue	go to state 6

State 3:

	$start -> all $end .	(Rule 0)

	$default	accept

State 4:

	inheritance -> L_INHERIT . string_const ';'	(Rule 8)

	L_CHARACTER	shift, and go to state 18
	L_HEXINTEGER	shift, and go to state 19
	L_INTEGER	shift, and go to state 15
	L_STRING	shift, and go to state 17

	string	go to state 13
	integer	go to state 14
	string_const	go to state 16

State 5:

	definition -> inheritance .	(Rule 4)

	$default	reduce using rule 4 (definition)

State 6:

	prototype -> function_prologue . ';'	(Rule 19)
	function -> function_prologue . block	(Rule 20)

	';'	shift, and go to state 20
	'{'	shift, and go to state 21

	block	go to state 22

State 7:

	type_modifier_list -> L_TYPE_MODIFIER . type_modifier_list	(Rule 156)

	L_TYPE_MODIFIER	shift, and go to state 7

	$default	reduce using rule 155 (type_modifier_list)

	type_modifier_list	go to state 23

State 8:

	definition -> function .	(Rule 6)

	$default	reduce using rule 6 (definition)

State 9:

	definition -> global_decl .	(Rule 5)

	$default	reduce using rule 5 (definition)

State 10:

	function_prologue -> type_modifier_list . type_specifier function_declarator	(Rule 18)
	global_decl -> type_modifier_list . type_specifier variable_declarator_list ';'	(Rule 144)

	L_BASIC_TYPE	shift, and go to state 24
	L_VOID	shift, and go to state 26

	type_specifier	go to state 25

State 11:

	definition -> prototype .	(Rule 7)

	$default	reduce using rule 7 (definition)

State 12:

	program -> program definition .	(Rule 2)

	$default	reduce using rule 2 (program)

State 13:

	string_const -> string .	(Rule 162)
	string -> string . L_STRING	(Rule 167)

	L_STRING	shift, and go to state 27

	$default	reduce using rule 162 (string_const)

State 14:

	string_const -> integer .	(Rule 165)

	$default	reduce using rule 165 (string_const)

State 15:

	integer -> L_INTEGER .	(Rule 168)

	$default	reduce using rule 168 (integer)

State 16:

	inheritance -> L_INHERIT string_const . ';'	(Rule 8)
	string_const -> string_const . '.' string_const	(Rule 163)
	string_const -> string_const . '+' string_const	(Rule 164)

	'+'	shift, and go to state 28
	'.'	shift, and go to state 30
	';'	shift, and go to state 29

State 17:

	string -> L_STRING .	(Rule 166)

	$default	reduce using rule 166 (string)

State 18:

	integer -> L_CHARACTER .	(Rule 170)

	$default	reduce using rule 170 (integer)

State 19:

	integer -> L_HEXINTEGER .	(Rule 169)

	$default	reduce using rule 169 (integer)

State 20:

	prototype -> function_prologue ';' .	(Rule 19)

	$default	reduce using rule 19 (prototype)

State 21:

	block -> '{' . @1-1 local_decls @2-3 statement_list '}'	(Rule 23)

	$default	reduce using rule 21 (@1-1)

	@1-1	go to state 31

State 22:

	function -> function_prologue block .	(Rule 20)

	$default	reduce using rule 20 (function)

State 23:

	type_modifier_list -> L_TYPE_MODIFIER type_modifier_list .	(Rule 156)

	$default	reduce using rule 156 (type_modifier_list)

State 24:

	type_specifier -> L_BASIC_TYPE .	(Rule 157)

	$default	reduce using rule 157 (type_specifier)

State 25:

	function_prologue -> type_modifier_list type_specifier . function_declarator	(Rule 18)
	global_decl -> type_modifier_list type_specifier . variable_declarator_list ';'	(Rule 144)

	$default	reduce using rule 159 (star_list)

	variable_declarator_list	go to state 34
	star_list	go to state 33
	function_declarator	go to state 32
	variable_declarator	go to state 35

State 26:

	type_specifier -> L_VOID .	(Rule 158)

	$default	reduce using rule 158 (type_specifier)

State 27:

	string -> string L_STRING .	(Rule 167)

	$default	reduce using rule 167 (string)

State 28:

	string_const -> string_const '+' . string_const	(Rule 164)

	L_CHARACTER	shift, and go to state 18
	L_HEXINTEGER	shift, and go to state 19
	L_INTEGER	shift, and go to state 15
	L_STRING	shift, and go to state 17

	string	go to state 13
	integer	go to state 14
	string_const	go to state 36

State 29:

	inheritance -> L_INHERIT string_const ';' .	(Rule 8)

	$default	reduce using rule 8 (inheritance)

State 30:

	string_const -> string_const '.' . string_const	(Rule 163)

	L_CHARACTER	shift, and go to state 18
	L_HEXINTEGER	shift, and go to state 19
	L_INTEGER	shift, and go to state 15
	L_STRING	shift, and go to state 17

	string	go to state 13
	integer	go to state 14
	string_const	go to state 37

State 31:

	block -> '{' @1-1 . local_decls @2-3 statement_list '}'	(Rule 23)

	$default	reduce using rule 145 (local_decls)

	local_decls	go to state 38

State 32:

	function_prologue -> type_modifier_list type_specifier function_declarator .	(Rule 18)

	$default	reduce using rule 18 (function_prologue)

State 33:

	function_declarator -> star_list . identifier '(' arguments ')'	(Rule 10)
	variable_declarator -> star_list . identifier	(Rule 11)
	star_list -> star_list . '*'	(Rule 160)
	star_list -> star_list . '#'	(Rule 161)

	'#'	shift, and go to state 40
	'*'	shift, and go to state 39
	L_IDENTIFIER	shift, and go to state 41

	identifier	go to state 42

State 34:

	variable_declarator_list -> variable_declarator_list . ',' variable_declarator	(Rule 13)
	global_decl -> type_modifier_list type_specifier variable_declarator_list . ';'	(Rule 144)

	','	shift, and go to state 44
	';'	shift, and go to state 43

State 35:

	variable_declarator_list -> variable_declarator .	(Rule 12)

	$default	reduce using rule 12 (variable_declarator_list)

State 36:

	string_const -> string_const . '.' string_const	(Rule 163)
	string_const -> string_const . '+' string_const	(Rule 164)
	string_const -> string_const '+' string_const .	(Rule 164)

	$default	reduce using rule 164 (string_const)

State 37:

	string_const -> string_const . '.' string_const	(Rule 163)
	string_const -> string_const '.' string_const .	(Rule 163)
	string_const -> string_const . '+' string_const	(Rule 164)

	'+'	shift, and go to state 28

	$default	reduce using rule 163 (string_const)

State 38:

	block -> '{' @1-1 local_decls . @2-3 statement_list '}'	(Rule 23)
	local_decls -> local_decls . local_decl	(Rule 146)

	L_BASIC_TYPE	shift, and go to state 24
	L_VOID	shift, and go to state 26

	$default	reduce using rule 22 (@2-3)

	@2-3	go to state 47
	local_decl	go to state 45
	type_specifier	go to state 46

State 39:

	star_list -> star_list '*' .	(Rule 160)

	$default	reduce using rule 160 (star_list)

State 40:

	star_list -> star_list '#' .	(Rule 161)

	$default	reduce using rule 161 (star_list)

State 41:

	identifier -> L_IDENTIFIER .	(Rule 9)

	$default	reduce using rule 9 (identifier)

State 42:

	function_declarator -> star_list identifier . '(' arguments ')'	(Rule 10)
	variable_declarator -> star_list identifier .	(Rule 11)

	'('	shift, and go to state 48

	$default	reduce using rule 11 (variable_declarator)

State 43:

	global_decl -> type_modifier_list type_specifier variable_declarator_list ';' .	(Rule 144)

	$default	reduce using rule 144 (global_decl)

State 44:

	variable_declarator_list -> variable_declarator_list ',' . variable_declarator	(Rule 13)

	$default	reduce using rule 159 (star_list)

	star_list	go to state 49
	variable_declarator	go to state 50

State 45:

	local_decls -> local_decls local_decl .	(Rule 146)

	$default	reduce using rule 146 (local_decls)

State 46:

	local_decl -> type_specifier . variable_declarator_list_init ';'	(Rule 147)

	$default	reduce using rule 159 (star_list)

	variable_declarator_list_init	go to state 51
	variable_declarator_init	go to state 52
	star_list	go to state 49
	variable_declarator	go to state 53

State 47:

	block -> '{' @1-1 local_decls @2-3 . statement_list '}'	(Rule 23)

	error	shift, and go to state 54

	'!'	reduce using rule 24 (statement_list)
	'$'	reduce using rule 24 (statement_list)
	'('	reduce using rule 24 (statement_list)
	'+'	reduce using rule 24 (statement_list)
	'-'	reduce using rule 24 (statement_list)
	';'	reduce using rule 24 (statement_list)
	'{'	reduce using rule 24 (statement_list)
	'}'	reduce using rule 24 (statement_list)
	'~'	reduce using rule 24 (statement_list)
	L_ARRAY_START	reduce using rule 24 (statement_list)
	L_BREAK	reduce using rule 24 (statement_list)
	L_CASE	reduce using rule 24 (statement_list)
	L_CATCH	reduce using rule 24 (statement_list)
	L_CHARACTER	reduce using rule 24 (statement_list)
	L_COLONCOLON	reduce using rule 24 (statement_list)
	L_CONTINUE	reduce using rule 24 (statement_list)
	L_DEC	reduce using rule 24 (statement_list)
	L_DEFAULT	reduce using rule 24 (statement_list)
	L_DO	reduce using rule 24 (statement_list)
	L_EFUN	reduce using rule 24 (statement_list)
	L_FOR	reduce using rule 24 (statement_list)
	L_FOREACH	reduce using rule 24 (statement_list)
	L_FUNCTION_START	reduce using rule 24 (statement_list)
	L_HEXINTEGER	reduce using rule 24 (statement_list)
	L_IDENTIFIER	reduce using rule 24 (statement_list)
	L_IF	reduce using rule 24 (statement_list)
	L_INC	reduce using rule 24 (statement_list)
	L_INTEGER	reduce using rule 24 (statement_list)
	L_MAP_START	reduce using rule 24 (statement_list)
	L_NIL	reduce using rule 24 (statement_list)
	L_PARAMETER	reduce using rule 24 (statement_list)
	L_RETURN	reduce using rule 24 (statement_list)
	L_RLIMITS	reduce using rule 24 (statement_list)
	L_SSCANF	reduce using rule 24 (statement_list)
	L_STRING	reduce using rule 24 (statement_list)
	L_SWITCH	reduce using rule 24 (statement_list)
	L_TRY	reduce using rule 24 (statement_list)
	L_WHILE	reduce using rule 24 (statement_list)

	statement_list	go to state 55

State 48:

	function_declarator -> star_list identifier '(' . arguments ')'	(Rule 10)

	L_BASIC_TYPE	shift, and go to state 24
	L_VOID	shift, and go to state 60

	$default	reduce using rule 148 (arguments)

	arguments	go to state 56
	type_specifier	go to state 57
	argument_list	go to state 58
	argument	go to state 59

State 49:

	variable_declarator -> star_list . identifier	(Rule 11)
	star_list -> star_list . '*'	(Rule 160)
	star_list -> star_list . '#'	(Rule 161)

	'#'	shift, and go to state 40
	'*'	shift, and go to state 39
	L_IDENTIFIER	shift, and go to state 41

	identifier	go to state 61

State 50:

	variable_declarator_list -> variable_declarator_list ',' variable_declarator .	(Rule 13)

	$default	reduce using rule 13 (variable_declarator_list)

State 51:

	variable_declarator_list_init -> variable_declarator_list_init . ',' variable_declarator_init	(Rule 17)
	local_decl -> type_specifier variable_declarator_list_init . ';'	(Rule 147)

	','	shift, and go to state 63
	';'	shift, and go to state 62

State 52:

	variable_declarator_list_init -> variable_declarator_init .	(Rule 16)

	$default	reduce using rule 16 (variable_declarator_list_init)

State 53:

	variable_declarator_init -> variable_declarator .	(Rule 14)
	variable_declarator_init -> variable_declarator . '=' exp	(Rule 15)

	'='	shift, and go to state 64

	$default	reduce using rule 14 (variable_declarator_init)

State 54:

	statement_list -> error . ';'	(Rule 26)

	';'	shift, and go to state 65

State 55:

	block -> '{' @1-1 local_decls @2-3 statement_list . '}'	(Rule 23)
	statement_list -> statement_list . statement	(Rule 25)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'}'	shift, and go to state 81
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	compare_exp	go to state 93
	logical_exp	go to state 92
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 77
	postfix_exp	go to state 109
	exp	go to state 108
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 56:

	function_declarator -> star_list identifier '(' arguments . ')'	(Rule 10)

	')'	shift, and go to state 118

State 57:

	argument -> type_specifier . variable_declarator	(Rule 154)

	$default	reduce using rule 159 (star_list)

	star_list	go to state 49
	variable_declarator	go to state 119

State 58:

	arguments -> argument_list .	(Rule 150)
	arguments -> argument_list . L_ELLIPSIS	(Rule 151)
	argument_list -> argument_list . ',' argument	(Rule 153)

	','	shift, and go to state 120
	L_ELLIPSIS	shift, and go to state 121

	$default	reduce using rule 150 (arguments)

State 59:

	argument_list -> argument .	(Rule 152)

	$default	reduce using rule 152 (argument_list)

State 60:

	arguments -> L_VOID .	(Rule 149)
	type_specifier -> L_VOID .	(Rule 158)

	')'	reduce using rule 149 (arguments)
	$default	reduce using rule 158 (type_specifier)

State 61:

	variable_declarator -> star_list identifier .	(Rule 11)

	$default	reduce using rule 11 (variable_declarator)

State 62:

	local_decl -> type_specifier variable_declarator_list_init ';' .	(Rule 147)

	$default	reduce using rule 147 (local_decl)

State 63:

	variable_declarator_list_init -> variable_declarator_list_init ',' . variable_declarator_init	(Rule 17)

	$default	reduce using rule 159 (star_list)

	variable_declarator_init	go to state 122
	star_list	go to state 49
	variable_declarator	go to state 53

State 64:

	variable_declarator_init -> variable_declarator '=' . exp	(Rule 15)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 123
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 65:

	statement_list -> error ';' .	(Rule 26)

	$default	reduce using rule 26 (statement_list)

State 66:

	statement -> L_DEFAULT . ':'	(Rule 46)

	':'	shift, and go to state 125

State 67:

	compare_exp -> arith_exp .	(Rule 97)
	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	'%'	shift, and go to state 129
	'*'	shift, and go to state 127
	'+'	shift, and go to state 130
	'-'	shift, and go to state 132
	'.'	shift, and go to state 128
	'/'	shift, and go to state 133
	L_LSH	shift, and go to state 131
	L_RSH	shift, and go to state 126

	$default	reduce using rule 97 (compare_exp)

State 68:

	mapping -> L_MAP_START . opt_assoc_arg_list_comma L_MAP_END	(Rule 172)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 70 (opt_assoc_arg_list_comma)

	assoc_arg_list	go to state 134
	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	opt_assoc_arg_list_comma	go to state 135
	closure	go to state 104
	integer	go to state 105
	assoc_exp	go to state 136
	exp	go to state 137
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 69:

	basic_exp -> '$' . '(' identifier ')'	(Rule 136)

	'('	shift, and go to state 138

State 70:

	array_exp -> basic_exp .	(Rule 123)

	$default	reduce using rule 123 (array_exp)

State 71:

	statement -> L_DO . @3-1 statement @4-3 L_WHILE '(' nv_list_exp ')' ';'	(Rule 32)

	$default	reduce using rule 30 (@3-1)

	@3-1	go to state 139

State 72:

	arith_exp -> prefix_exp .	(Rule 104)

	$default	reduce using rule 104 (arith_exp)

State 73:

	exp -> cond_exp .	(Rule 78)

	$default	reduce using rule 78 (exp)

State 74:

	basic_exp -> '(' . list_exp ')'	(Rule 137)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 140
	function_name	go to state 80
	identifier	go to state 83

State 75:

	basic_exp -> string .	(Rule 129)
	string -> string . L_STRING	(Rule 167)

	L_STRING	shift, and go to state 27

	$default	reduce using rule 129 (basic_exp)

State 76:

	statement -> L_RETURN . opt_nv_list_exp ';'	(Rule 49)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 58 (opt_nv_list_exp)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 142
	closure	go to state 104
	integer	go to state 105
	opt_nv_list_exp	go to state 141
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 77:

	statement_list -> statement_list statement .	(Rule 25)

	$default	reduce using rule 25 (statement_list)

State 78:

	statement -> ';' .	(Rule 50)

	$default	reduce using rule 50 (statement)

State 79:

	statement -> L_RLIMITS . '(' nv_list_exp ';' nv_list_exp ')' statement	(Rule 39)

	'('	shift, and go to state 144

State 80:

	basic_exp -> function_name . '(' opt_arg_list ')'	(Rule 138)

	'('	shift, and go to state 145

State 81:

	block -> '{' @1-1 local_decls @2-3 statement_list '}' .	(Rule 23)

	$default	reduce using rule 23 (block)

State 82:

	statement -> L_FOREACH . '(' lvalue L_IN exp ')' @7-6 statement	(Rule 38)

	'('	shift, and go to state 146

State 83:

	function_name -> identifier .	(Rule 73)
	function_name -> identifier . L_COLONCOLON identifier	(Rule 75)
	basic_exp -> identifier .	(Rule 134)

	L_COLONCOLON	shift, and go to state 147

	'('	reduce using rule 73 (function_name)
	$default	reduce using rule 134 (basic_exp)

State 84:

	statement -> L_CONTINUE . ';'	(Rule 48)

	';'	shift, and go to state 148

State 85:

	prefix_exp -> L_INC . prefix_exp	(Rule 114)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	prefix_exp	go to state 149
	array	go to state 101

State 86:

	function_name -> L_COLONCOLON . identifier	(Rule 74)

	L_IDENTIFIER	shift, and go to state 41

	identifier	go to state 151

State 87:

	exp -> lvalue . '=' exp	(Rule 79)
	exp -> lvalue . L_PLUS_EQ exp	(Rule 80)
	exp -> lvalue . L_MINUS_EQ exp	(Rule 81)
	exp -> lvalue . L_DIV_EQ exp	(Rule 82)
	exp -> lvalue . L_TIMES_EQ exp	(Rule 83)
	exp -> lvalue . L_MOD_EQ exp	(Rule 84)
	exp -> lvalue . L_AND_EQ exp	(Rule 85)
	exp -> lvalue . L_OR_EQ exp	(Rule 86)
	exp -> lvalue . L_XOR_EQ exp	(Rule 87)
	exp -> lvalue . L_DOT_EQ exp	(Rule 88)

	'='	shift, and go to state 156
	L_AND_EQ	shift, and go to state 157
	L_DIV_EQ	shift, and go to state 152
	L_DOT_EQ	shift, and go to state 155
	L_MINUS_EQ	shift, and go to state 160
	L_MOD_EQ	shift, and go to state 159
	L_OR_EQ	shift, and go to state 154
	L_PLUS_EQ	shift, and go to state 158
	L_TIMES_EQ	shift, and go to state 161
	L_XOR_EQ	shift, and go to state 153

State 88:

	prefix_exp -> '!' . prefix_exp	(Rule 116)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	prefix_exp	go to state 162
	array	go to state 101

State 89:

	lvalue -> array_exp .	(Rule 77)
	postfix_exp -> array_exp .	(Rule 120)
	array_exp -> array_exp . '[' opt_endrange nv_list_exp ']'	(Rule 124)
	array_exp -> array_exp . '[' opt_endrange nv_list_exp L_RANGE opt_endrange nv_list_exp ']'	(Rule 125)
	basic_exp -> array_exp . L_ARROW identifier '(' opt_arg_list ')'	(Rule 141)

	'['	shift, and go to state 164
	L_ARROW	shift, and go to state 163

	'='	reduce using rule 77 (lvalue)
	L_AND_EQ	reduce using rule 77 (lvalue)
	L_DIV_EQ	reduce using rule 77 (lvalue)
	L_DOT_EQ	reduce using rule 77 (lvalue)
	L_MINUS_EQ	reduce using rule 77 (lvalue)
	L_MOD_EQ	reduce using rule 77 (lvalue)
	L_OR_EQ	reduce using rule 77 (lvalue)
	L_PLUS_EQ	reduce using rule 77 (lvalue)
	L_TIMES_EQ	reduce using rule 77 (lvalue)
	L_XOR_EQ	reduce using rule 77 (lvalue)
	$default	reduce using rule 120 (postfix_exp)

State 90:

	basic_exp -> mapping .	(Rule 132)

	$default	reduce using rule 132 (basic_exp)

State 91:

	statement -> L_FOR . '(' opt_list_exp ';' opt_nv_list_exp ';' opt_list_exp ')' @6-8 statement	(Rule 36)

	'('	shift, and go to state 165

State 92:

	cond_exp -> logical_exp .	(Rule 89)
	cond_exp -> logical_exp . '?' list_exp ':' cond_exp	(Rule 90)
	logical_exp -> logical_exp . L_LOR logical_exp	(Rule 92)
	logical_exp -> logical_exp . L_LAND logical_exp	(Rule 93)
	logical_exp -> logical_exp . '|' logical_exp	(Rule 94)
	logical_exp -> logical_exp . '^' logical_exp	(Rule 95)
	logical_exp -> logical_exp . '&' logical_exp	(Rule 96)

	'&'	shift, and go to state 166
	'?'	shift, and go to state 167
	'^'	shift, and go to state 171
	'|'	shift, and go to state 170
	L_LAND	shift, and go to state 168
	L_LOR	shift, and go to state 169

	$default	reduce using rule 89 (cond_exp)

State 93:

	logical_exp -> compare_exp .	(Rule 91)
	compare_exp -> compare_exp . L_EQ compare_exp	(Rule 98)
	compare_exp -> compare_exp . L_NE compare_exp	(Rule 99)
	compare_exp -> compare_exp . '<' compare_exp	(Rule 100)
	compare_exp -> compare_exp . '>' compare_exp	(Rule 101)
	compare_exp -> compare_exp . L_LE compare_exp	(Rule 102)
	compare_exp -> compare_exp . L_GE compare_exp	(Rule 103)

	'<'	shift, and go to state 176
	'>'	shift, and go to state 177
	L_EQ	shift, and go to state 175
	L_GE	shift, and go to state 174
	L_LE	shift, and go to state 172
	L_NE	shift, and go to state 173

	$default	reduce using rule 91 (logical_exp)

State 94:

	statement -> block .	(Rule 28)

	$default	reduce using rule 28 (statement)

State 95:

	statement -> L_WHILE . '(' nv_list_exp ')' @5-4 statement	(Rule 34)

	'('	shift, and go to state 178

State 96:

	statement -> L_CASE . exp ':'	(Rule 44)
	statement -> L_CASE . exp L_RANGE exp ':'	(Rule 45)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 179
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 97:

	array -> L_ARRAY_START . opt_arg_list_comma L_ARRAY_END	(Rule 171)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 64 (opt_arg_list_comma)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	arg_list	go to state 180
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 181
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83
	opt_arg_list_comma	go to state 182

State 98:

	basic_exp -> L_NIL .	(Rule 128)

	$default	reduce using rule 128 (basic_exp)

State 99:

	statement -> L_BREAK . ';'	(Rule 47)

	';'	shift, and go to state 183

State 100:

	basic_exp -> L_SSCANF . '(' exp lvalue_list ')'	(Rule 139)

	'('	shift, and go to state 184

State 101:

	basic_exp -> array .	(Rule 131)

	$default	reduce using rule 131 (basic_exp)

State 102:

	statement -> L_IF . '(' nv_list_exp ')' statement opt_else	(Rule 29)

	'('	shift, and go to state 185

State 103:

	function_name -> L_EFUN . L_COLONCOLON identifier	(Rule 76)

	L_COLONCOLON	shift, and go to state 186

State 104:

	basic_exp -> closure .	(Rule 133)

	$default	reduce using rule 133 (basic_exp)

State 105:

	basic_exp -> integer .	(Rule 130)

	$default	reduce using rule 130 (basic_exp)

State 106:

	prefix_exp -> '+' . prefix_exp	(Rule 118)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	prefix_exp	go to state 187
	array	go to state 101

State 107:

	prefix_exp -> '-' . prefix_exp	(Rule 119)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	prefix_exp	go to state 188
	array	go to state 101

State 108:

	list_exp -> exp .	(Rule 53)

	$default	reduce using rule 53 (list_exp)

State 109:

	prefix_exp -> postfix_exp .	(Rule 113)
	postfix_exp -> postfix_exp . L_INC	(Rule 121)
	postfix_exp -> postfix_exp . L_DEC	(Rule 122)

	L_DEC	shift, and go to state 190
	L_INC	shift, and go to state 189

	$default	reduce using rule 113 (prefix_exp)

State 110:

	statement -> L_CATCH . block	(Rule 41)
	basic_exp -> L_CATCH . '(' list_exp ')'	(Rule 140)

	'('	shift, and go to state 191
	'{'	shift, and go to state 21

	block	go to state 192

State 111:

	statement -> list_exp . ';'	(Rule 27)
	list_exp -> list_exp . ',' exp	(Rule 54)

	','	shift, and go to state 194
	';'	shift, and go to state 193

State 112:

	prefix_exp -> L_DEC . prefix_exp	(Rule 115)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	prefix_exp	go to state 195
	array	go to state 101

State 113:

	closure -> L_FUNCTION_START . list_exp L_FUNCTION_END	(Rule 173)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 196
	function_name	go to state 80
	identifier	go to state 83

State 114:

	basic_exp -> L_PARAMETER .	(Rule 135)

	$default	reduce using rule 135 (basic_exp)

State 115:

	statement -> L_TRY . block L_CATCH '(' lvalue ')' block	(Rule 40)

	'{'	shift, and go to state 21

	block	go to state 197

State 116:

	prefix_exp -> '~' . prefix_exp	(Rule 117)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	prefix_exp	go to state 198
	array	go to state 101

State 117:

	statement -> L_SWITCH . '(' nv_list_exp ')' @8-4 block	(Rule 43)

	'('	shift, and go to state 199

State 118:

	function_declarator -> star_list identifier '(' arguments ')' .	(Rule 10)

	$default	reduce using rule 10 (function_declarator)

State 119:

	argument -> type_specifier variable_declarator .	(Rule 154)

	$default	reduce using rule 154 (argument)

State 120:

	argument_list -> argument_list ',' . argument	(Rule 153)

	L_BASIC_TYPE	shift, and go to state 24
	L_VOID	shift, and go to state 26

	type_specifier	go to state 57
	argument	go to state 200

State 121:

	arguments -> argument_list L_ELLIPSIS .	(Rule 151)

	$default	reduce using rule 151 (arguments)

State 122:

	variable_declarator_list_init -> variable_declarator_list_init ',' variable_declarator_init .	(Rule 17)

	$default	reduce using rule 17 (variable_declarator_list_init)

State 123:

	variable_declarator_init -> variable_declarator '=' exp .	(Rule 15)

	$default	reduce using rule 15 (variable_declarator_init)

State 124:

	basic_exp -> L_CATCH . '(' list_exp ')'	(Rule 140)

	'('	shift, and go to state 191

State 125:

	statement -> L_DEFAULT ':' .	(Rule 46)

	$default	reduce using rule 46 (statement)

State 126:

	arith_exp -> arith_exp L_RSH . arith_exp	(Rule 106)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 201
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 127:

	arith_exp -> arith_exp '*' . arith_exp	(Rule 110)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 202
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 128:

	arith_exp -> arith_exp '.' . arith_exp	(Rule 107)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 203
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 129:

	arith_exp -> arith_exp '%' . arith_exp	(Rule 112)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 204
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 130:

	arith_exp -> arith_exp '+' . arith_exp	(Rule 108)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 205
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 131:

	arith_exp -> arith_exp L_LSH . arith_exp	(Rule 105)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 206
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 132:

	arith_exp -> arith_exp '-' . arith_exp	(Rule 109)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 207
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 133:

	arith_exp -> arith_exp '/' . arith_exp	(Rule 111)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	postfix_exp	go to state 109
	arith_exp	go to state 208
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90
	prefix_exp	go to state 72

State 134:

	assoc_arg_list -> assoc_arg_list . ',' assoc_exp	(Rule 69)
	opt_assoc_arg_list_comma -> assoc_arg_list .	(Rule 71)
	opt_assoc_arg_list_comma -> assoc_arg_list . ','	(Rule 72)

	','	shift, and go to state 209

	$default	reduce using rule 71 (opt_assoc_arg_list_comma)

State 135:

	mapping -> L_MAP_START opt_assoc_arg_list_comma . L_MAP_END	(Rule 172)

	L_MAP_END	shift, and go to state 210

State 136:

	assoc_arg_list -> assoc_exp .	(Rule 68)

	$default	reduce using rule 68 (assoc_arg_list)

State 137:

	assoc_exp -> exp . ':' exp	(Rule 67)

	':'	shift, and go to state 211

State 138:

	basic_exp -> '$' '(' . identifier ')'	(Rule 136)

	L_IDENTIFIER	shift, and go to state 41

	identifier	go to state 212

State 139:

	statement -> L_DO @3-1 . statement @4-3 L_WHILE '(' nv_list_exp ')' ';'	(Rule 32)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 213
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 140:

	list_exp -> list_exp . ',' exp	(Rule 54)
	basic_exp -> '(' list_exp . ')'	(Rule 137)

	')'	shift, and go to state 214
	','	shift, and go to state 194

State 141:

	statement -> L_RETURN opt_nv_list_exp . ';'	(Rule 49)

	';'	shift, and go to state 215

State 142:

	opt_nv_list_exp -> nv_list_exp .	(Rule 59)

	$default	reduce using rule 59 (opt_nv_list_exp)

State 143:

	nv_list_exp -> exp .	(Rule 57)

	$default	reduce using rule 57 (nv_list_exp)

State 144:

	statement -> L_RLIMITS '(' . nv_list_exp ';' nv_list_exp ')' statement	(Rule 39)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 216
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 145:

	basic_exp -> function_name '(' . opt_arg_list ')'	(Rule 138)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 62 (opt_arg_list)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	arg_list	go to state 218
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 181
	postfix_exp	go to state 109
	opt_arg_list	go to state 217
	function_name	go to state 80
	identifier	go to state 83

State 146:

	statement -> L_FOREACH '(' . lvalue L_IN exp ')' @7-6 statement	(Rule 38)

	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	lvalue	go to state 219
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 220
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90

State 147:

	function_name -> identifier L_COLONCOLON . identifier	(Rule 75)

	L_IDENTIFIER	shift, and go to state 41

	identifier	go to state 221

State 148:

	statement -> L_CONTINUE ';' .	(Rule 48)

	$default	reduce using rule 48 (statement)

State 149:

	prefix_exp -> L_INC prefix_exp .	(Rule 114)

	$default	reduce using rule 114 (prefix_exp)

State 150:

	postfix_exp -> array_exp .	(Rule 120)
	array_exp -> array_exp . '[' opt_endrange nv_list_exp ']'	(Rule 124)
	array_exp -> array_exp . '[' opt_endrange nv_list_exp L_RANGE opt_endrange nv_list_exp ']'	(Rule 125)
	basic_exp -> array_exp . L_ARROW identifier '(' opt_arg_list ')'	(Rule 141)

	'['	shift, and go to state 164
	L_ARROW	shift, and go to state 163

	$default	reduce using rule 120 (postfix_exp)

State 151:

	function_name -> L_COLONCOLON identifier .	(Rule 74)

	$default	reduce using rule 74 (function_name)

State 152:

	exp -> lvalue L_DIV_EQ . exp	(Rule 82)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 222
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 153:

	exp -> lvalue L_XOR_EQ . exp	(Rule 87)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 223
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 154:

	exp -> lvalue L_OR_EQ . exp	(Rule 86)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 224
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 155:

	exp -> lvalue L_DOT_EQ . exp	(Rule 88)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 225
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 156:

	exp -> lvalue '=' . exp	(Rule 79)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 226
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 157:

	exp -> lvalue L_AND_EQ . exp	(Rule 85)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 227
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 158:

	exp -> lvalue L_PLUS_EQ . exp	(Rule 80)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 228
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 159:

	exp -> lvalue L_MOD_EQ . exp	(Rule 84)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 229
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 160:

	exp -> lvalue L_MINUS_EQ . exp	(Rule 81)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 230
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 161:

	exp -> lvalue L_TIMES_EQ . exp	(Rule 83)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 231
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 162:

	prefix_exp -> '!' prefix_exp .	(Rule 116)

	$default	reduce using rule 116 (prefix_exp)

State 163:

	basic_exp -> array_exp L_ARROW . identifier '(' opt_arg_list ')'	(Rule 141)

	L_IDENTIFIER	shift, and go to state 41

	identifier	go to state 232

State 164:

	array_exp -> array_exp '[' . opt_endrange nv_list_exp ']'	(Rule 124)
	array_exp -> array_exp '[' . opt_endrange nv_list_exp L_RANGE opt_endrange nv_list_exp ']'	(Rule 125)

	'<'	shift, and go to state 234

	$default	reduce using rule 126 (opt_endrange)

	opt_endrange	go to state 233

State 165:

	statement -> L_FOR '(' . opt_list_exp ';' opt_nv_list_exp ';' opt_list_exp ')' @6-8 statement	(Rule 36)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 55 (opt_list_exp)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	opt_list_exp	go to state 235
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 236
	function_name	go to state 80
	identifier	go to state 83

State 166:

	logical_exp -> logical_exp '&' . logical_exp	(Rule 96)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	logical_exp	go to state 237
	compare_exp	go to state 93
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 167:

	cond_exp -> logical_exp '?' . list_exp ':' cond_exp	(Rule 90)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 238
	function_name	go to state 80
	identifier	go to state 83

State 168:

	logical_exp -> logical_exp L_LAND . logical_exp	(Rule 93)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	logical_exp	go to state 239
	compare_exp	go to state 93
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 169:

	logical_exp -> logical_exp L_LOR . logical_exp	(Rule 92)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	logical_exp	go to state 240
	compare_exp	go to state 93
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 170:

	logical_exp -> logical_exp '|' . logical_exp	(Rule 94)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	logical_exp	go to state 241
	compare_exp	go to state 93
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 171:

	logical_exp -> logical_exp '^' . logical_exp	(Rule 95)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	logical_exp	go to state 242
	compare_exp	go to state 93
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 172:

	compare_exp -> compare_exp L_LE . compare_exp	(Rule 102)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	compare_exp	go to state 243
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 173:

	compare_exp -> compare_exp L_NE . compare_exp	(Rule 99)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	compare_exp	go to state 244
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 174:

	compare_exp -> compare_exp L_GE . compare_exp	(Rule 103)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	compare_exp	go to state 245
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 175:

	compare_exp -> compare_exp L_EQ . compare_exp	(Rule 98)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	compare_exp	go to state 246
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 176:

	compare_exp -> compare_exp '<' . compare_exp	(Rule 100)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	compare_exp	go to state 247
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 177:

	compare_exp -> compare_exp '>' . compare_exp	(Rule 101)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	compare_exp	go to state 248
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72

State 178:

	statement -> L_WHILE '(' . nv_list_exp ')' @5-4 statement	(Rule 34)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 249
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 179:

	statement -> L_CASE exp . ':'	(Rule 44)
	statement -> L_CASE exp . L_RANGE exp ':'	(Rule 45)

	':'	shift, and go to state 250
	L_RANGE	shift, and go to state 251

State 180:

	arg_list -> arg_list . ',' exp	(Rule 61)
	opt_arg_list_comma -> arg_list .	(Rule 65)
	opt_arg_list_comma -> arg_list . ','	(Rule 66)

	','	shift, and go to state 252

	$default	reduce using rule 65 (opt_arg_list_comma)

State 181:

	arg_list -> exp .	(Rule 60)

	$default	reduce using rule 60 (arg_list)

State 182:

	array -> L_ARRAY_START opt_arg_list_comma . L_ARRAY_END	(Rule 171)

	L_ARRAY_END	shift, and go to state 253

State 183:

	statement -> L_BREAK ';' .	(Rule 47)

	$default	reduce using rule 47 (statement)

State 184:

	basic_exp -> L_SSCANF '(' . exp lvalue_list ')'	(Rule 139)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 254
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 185:

	statement -> L_IF '(' . nv_list_exp ')' statement opt_else	(Rule 29)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 255
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 186:

	function_name -> L_EFUN L_COLONCOLON . identifier	(Rule 76)

	L_IDENTIFIER	shift, and go to state 41

	identifier	go to state 256

State 187:

	prefix_exp -> '+' prefix_exp .	(Rule 118)

	$default	reduce using rule 118 (prefix_exp)

State 188:

	prefix_exp -> '-' prefix_exp .	(Rule 119)

	$default	reduce using rule 119 (prefix_exp)

State 189:

	postfix_exp -> postfix_exp L_INC .	(Rule 121)

	$default	reduce using rule 121 (postfix_exp)

State 190:

	postfix_exp -> postfix_exp L_DEC .	(Rule 122)

	$default	reduce using rule 122 (postfix_exp)

State 191:

	basic_exp -> L_CATCH '(' . list_exp ')'	(Rule 140)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 257
	function_name	go to state 80
	identifier	go to state 83

State 192:

	statement -> L_CATCH block .	(Rule 41)

	$default	reduce using rule 41 (statement)

State 193:

	statement -> list_exp ';' .	(Rule 27)

	$default	reduce using rule 27 (statement)

State 194:

	list_exp -> list_exp ',' . exp	(Rule 54)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 258
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 195:

	prefix_exp -> L_DEC prefix_exp .	(Rule 115)

	$default	reduce using rule 115 (prefix_exp)

State 196:

	list_exp -> list_exp . ',' exp	(Rule 54)
	closure -> L_FUNCTION_START list_exp . L_FUNCTION_END	(Rule 173)

	','	shift, and go to state 194
	L_FUNCTION_END	shift, and go to state 259

State 197:

	statement -> L_TRY block . L_CATCH '(' lvalue ')' block	(Rule 40)

	L_CATCH	shift, and go to state 260

State 198:

	prefix_exp -> '~' prefix_exp .	(Rule 117)

	$default	reduce using rule 117 (prefix_exp)

State 199:

	statement -> L_SWITCH '(' . nv_list_exp ')' @8-4 block	(Rule 43)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 261
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 200:

	argument_list -> argument_list ',' argument .	(Rule 153)

	$default	reduce using rule 153 (argument_list)

State 201:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp L_RSH arith_exp .	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	'%'	shift, and go to state 129
	'*'	shift, and go to state 127
	'+'	shift, and go to state 130
	'-'	shift, and go to state 132
	'.'	shift, and go to state 128
	'/'	shift, and go to state 133

	$default	reduce using rule 106 (arith_exp)

State 202:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp '*' arith_exp .	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	$default	reduce using rule 110 (arith_exp)

State 203:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp '.' arith_exp .	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	'%'	shift, and go to state 129
	'*'	shift, and go to state 127
	'+'	shift, and go to state 130
	'-'	shift, and go to state 132
	'/'	shift, and go to state 133

	$default	reduce using rule 107 (arith_exp)

State 204:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)
	arith_exp -> arith_exp '%' arith_exp .	(Rule 112)

	$default	reduce using rule 112 (arith_exp)

State 205:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp '+' arith_exp .	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	'%'	shift, and go to state 129
	'*'	shift, and go to state 127
	'/'	shift, and go to state 133

	$default	reduce using rule 108 (arith_exp)

State 206:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp L_LSH arith_exp .	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	'%'	shift, and go to state 129
	'*'	shift, and go to state 127
	'+'	shift, and go to state 130
	'-'	shift, and go to state 132
	'.'	shift, and go to state 128
	'/'	shift, and go to state 133

	$default	reduce using rule 105 (arith_exp)

State 207:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp '-' arith_exp .	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	'%'	shift, and go to state 129
	'*'	shift, and go to state 127
	'/'	shift, and go to state 133

	$default	reduce using rule 109 (arith_exp)

State 208:

	arith_exp -> arith_exp . L_LSH arith_exp	(Rule 105)
	arith_exp -> arith_exp . L_RSH arith_exp	(Rule 106)
	arith_exp -> arith_exp . '.' arith_exp	(Rule 107)
	arith_exp -> arith_exp . '+' arith_exp	(Rule 108)
	arith_exp -> arith_exp . '-' arith_exp	(Rule 109)
	arith_exp -> arith_exp . '*' arith_exp	(Rule 110)
	arith_exp -> arith_exp . '/' arith_exp	(Rule 111)
	arith_exp -> arith_exp '/' arith_exp .	(Rule 111)
	arith_exp -> arith_exp . '%' arith_exp	(Rule 112)

	$default	reduce using rule 111 (arith_exp)

State 209:

	assoc_arg_list -> assoc_arg_list ',' . assoc_exp	(Rule 69)
	opt_assoc_arg_list_comma -> assoc_arg_list ',' .	(Rule 72)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 72 (opt_assoc_arg_list_comma)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	assoc_exp	go to state 262
	exp	go to state 137
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 210:

	mapping -> L_MAP_START opt_assoc_arg_list_comma L_MAP_END .	(Rule 172)

	$default	reduce using rule 172 (mapping)

State 211:

	assoc_exp -> exp ':' . exp	(Rule 67)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 263
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 212:

	basic_exp -> '$' '(' identifier . ')'	(Rule 136)

	')'	shift, and go to state 264

State 213:

	statement -> L_DO @3-1 statement . @4-3 L_WHILE '(' nv_list_exp ')' ';'	(Rule 32)

	$default	reduce using rule 31 (@4-3)

	@4-3	go to state 265

State 214:

	basic_exp -> '(' list_exp ')' .	(Rule 137)

	$default	reduce using rule 137 (basic_exp)

State 215:

	statement -> L_RETURN opt_nv_list_exp ';' .	(Rule 49)

	$default	reduce using rule 49 (statement)

State 216:

	statement -> L_RLIMITS '(' nv_list_exp . ';' nv_list_exp ')' statement	(Rule 39)

	';'	shift, and go to state 266

State 217:

	basic_exp -> function_name '(' opt_arg_list . ')'	(Rule 138)

	')'	shift, and go to state 267

State 218:

	arg_list -> arg_list . ',' exp	(Rule 61)
	opt_arg_list -> arg_list .	(Rule 63)

	','	shift, and go to state 268

	$default	reduce using rule 63 (opt_arg_list)

State 219:

	statement -> L_FOREACH '(' lvalue . L_IN exp ')' @7-6 statement	(Rule 38)

	L_IN	shift, and go to state 269

State 220:

	lvalue -> array_exp .	(Rule 77)
	array_exp -> array_exp . '[' opt_endrange nv_list_exp ']'	(Rule 124)
	array_exp -> array_exp . '[' opt_endrange nv_list_exp L_RANGE opt_endrange nv_list_exp ']'	(Rule 125)
	basic_exp -> array_exp . L_ARROW identifier '(' opt_arg_list ')'	(Rule 141)

	'['	shift, and go to state 164
	L_ARROW	shift, and go to state 163

	$default	reduce using rule 77 (lvalue)

State 221:

	function_name -> identifier L_COLONCOLON identifier .	(Rule 75)

	$default	reduce using rule 75 (function_name)

State 222:

	exp -> lvalue L_DIV_EQ exp .	(Rule 82)

	$default	reduce using rule 82 (exp)

State 223:

	exp -> lvalue L_XOR_EQ exp .	(Rule 87)

	$default	reduce using rule 87 (exp)

State 224:

	exp -> lvalue L_OR_EQ exp .	(Rule 86)

	$default	reduce using rule 86 (exp)

State 225:

	exp -> lvalue L_DOT_EQ exp .	(Rule 88)

	$default	reduce using rule 88 (exp)

State 226:

	exp -> lvalue '=' exp .	(Rule 79)

	$default	reduce using rule 79 (exp)

State 227:

	exp -> lvalue L_AND_EQ exp .	(Rule 85)

	$default	reduce using rule 85 (exp)

State 228:

	exp -> lvalue L_PLUS_EQ exp .	(Rule 80)

	$default	reduce using rule 80 (exp)

State 229:

	exp -> lvalue L_MOD_EQ exp .	(Rule 84)

	$default	reduce using rule 84 (exp)

State 230:

	exp -> lvalue L_MINUS_EQ exp .	(Rule 81)

	$default	reduce using rule 81 (exp)

State 231:

	exp -> lvalue L_TIMES_EQ exp .	(Rule 83)

	$default	reduce using rule 83 (exp)

State 232:

	basic_exp -> array_exp L_ARROW identifier . '(' opt_arg_list ')'	(Rule 141)

	'('	shift, and go to state 270

State 233:

	array_exp -> array_exp '[' opt_endrange . nv_list_exp ']'	(Rule 124)
	array_exp -> array_exp '[' opt_endrange . nv_list_exp L_RANGE opt_endrange nv_list_exp ']'	(Rule 125)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 271
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 234:

	opt_endrange -> '<' .	(Rule 127)

	$default	reduce using rule 127 (opt_endrange)

State 235:

	statement -> L_FOR '(' opt_list_exp . ';' opt_nv_list_exp ';' opt_list_exp ')' @6-8 statement	(Rule 36)

	';'	shift, and go to state 272

State 236:

	list_exp -> list_exp . ',' exp	(Rule 54)
	opt_list_exp -> list_exp .	(Rule 56)

	','	shift, and go to state 194

	$default	reduce using rule 56 (opt_list_exp)

State 237:

	logical_exp -> logical_exp . L_LOR logical_exp	(Rule 92)
	logical_exp -> logical_exp . L_LAND logical_exp	(Rule 93)
	logical_exp -> logical_exp . '|' logical_exp	(Rule 94)
	logical_exp -> logical_exp . '^' logical_exp	(Rule 95)
	logical_exp -> logical_exp . '&' logical_exp	(Rule 96)
	logical_exp -> logical_exp '&' logical_exp .	(Rule 96)

	$default	reduce using rule 96 (logical_exp)

State 238:

	list_exp -> list_exp . ',' exp	(Rule 54)
	cond_exp -> logical_exp '?' list_exp . ':' cond_exp	(Rule 90)

	','	shift, and go to state 194
	':'	shift, and go to state 273

State 239:

	logical_exp -> logical_exp . L_LOR logical_exp	(Rule 92)
	logical_exp -> logical_exp . L_LAND logical_exp	(Rule 93)
	logical_exp -> logical_exp L_LAND logical_exp .	(Rule 93)
	logical_exp -> logical_exp . '|' logical_exp	(Rule 94)
	logical_exp -> logical_exp . '^' logical_exp	(Rule 95)
	logical_exp -> logical_exp . '&' logical_exp	(Rule 96)

	'&'	shift, and go to state 166
	'^'	shift, and go to state 171
	'|'	shift, and go to state 170

	$default	reduce using rule 93 (logical_exp)

State 240:

	logical_exp -> logical_exp . L_LOR logical_exp	(Rule 92)
	logical_exp -> logical_exp L_LOR logical_exp .	(Rule 92)
	logical_exp -> logical_exp . L_LAND logical_exp	(Rule 93)
	logical_exp -> logical_exp . '|' logical_exp	(Rule 94)
	logical_exp -> logical_exp . '^' logical_exp	(Rule 95)
	logical_exp -> logical_exp . '&' logical_exp	(Rule 96)

	'&'	shift, and go to state 166
	'^'	shift, and go to state 171
	'|'	shift, and go to state 170
	L_LAND	shift, and go to state 168

	$default	reduce using rule 92 (logical_exp)

State 241:

	logical_exp -> logical_exp . L_LOR logical_exp	(Rule 92)
	logical_exp -> logical_exp . L_LAND logical_exp	(Rule 93)
	logical_exp -> logical_exp . '|' logical_exp	(Rule 94)
	logical_exp -> logical_exp '|' logical_exp .	(Rule 94)
	logical_exp -> logical_exp . '^' logical_exp	(Rule 95)
	logical_exp -> logical_exp . '&' logical_exp	(Rule 96)

	'&'	shift, and go to state 166
	'^'	shift, and go to state 171

	$default	reduce using rule 94 (logical_exp)

State 242:

	logical_exp -> logical_exp . L_LOR logical_exp	(Rule 92)
	logical_exp -> logical_exp . L_LAND logical_exp	(Rule 93)
	logical_exp -> logical_exp . '|' logical_exp	(Rule 94)
	logical_exp -> logical_exp . '^' logical_exp	(Rule 95)
	logical_exp -> logical_exp '^' logical_exp .	(Rule 95)
	logical_exp -> logical_exp . '&' logical_exp	(Rule 96)

	'&'	shift, and go to state 166

	$default	reduce using rule 95 (logical_exp)

State 243:

	compare_exp -> compare_exp . L_EQ compare_exp	(Rule 98)
	compare_exp -> compare_exp . L_NE compare_exp	(Rule 99)
	compare_exp -> compare_exp . '<' compare_exp	(Rule 100)
	compare_exp -> compare_exp . '>' compare_exp	(Rule 101)
	compare_exp -> compare_exp . L_LE compare_exp	(Rule 102)
	compare_exp -> compare_exp L_LE compare_exp .	(Rule 102)
	compare_exp -> compare_exp . L_GE compare_exp	(Rule 103)

	$default	reduce using rule 102 (compare_exp)

State 244:

	compare_exp -> compare_exp . L_EQ compare_exp	(Rule 98)
	compare_exp -> compare_exp . L_NE compare_exp	(Rule 99)
	compare_exp -> compare_exp L_NE compare_exp .	(Rule 99)
	compare_exp -> compare_exp . '<' compare_exp	(Rule 100)
	compare_exp -> compare_exp . '>' compare_exp	(Rule 101)
	compare_exp -> compare_exp . L_LE compare_exp	(Rule 102)
	compare_exp -> compare_exp . L_GE compare_exp	(Rule 103)

	'<'	shift, and go to state 176
	'>'	shift, and go to state 177
	L_GE	shift, and go to state 174
	L_LE	shift, and go to state 172

	$default	reduce using rule 99 (compare_exp)

State 245:

	compare_exp -> compare_exp . L_EQ compare_exp	(Rule 98)
	compare_exp -> compare_exp . L_NE compare_exp	(Rule 99)
	compare_exp -> compare_exp . '<' compare_exp	(Rule 100)
	compare_exp -> compare_exp . '>' compare_exp	(Rule 101)
	compare_exp -> compare_exp . L_LE compare_exp	(Rule 102)
	compare_exp -> compare_exp . L_GE compare_exp	(Rule 103)
	compare_exp -> compare_exp L_GE compare_exp .	(Rule 103)

	$default	reduce using rule 103 (compare_exp)

State 246:

	compare_exp -> compare_exp . L_EQ compare_exp	(Rule 98)
	compare_exp -> compare_exp L_EQ compare_exp .	(Rule 98)
	compare_exp -> compare_exp . L_NE compare_exp	(Rule 99)
	compare_exp -> compare_exp . '<' compare_exp	(Rule 100)
	compare_exp -> compare_exp . '>' compare_exp	(Rule 101)
	compare_exp -> compare_exp . L_LE compare_exp	(Rule 102)
	compare_exp -> compare_exp . L_GE compare_exp	(Rule 103)

	'<'	shift, and go to state 176
	'>'	shift, and go to state 177
	L_GE	shift, and go to state 174
	L_LE	shift, and go to state 172

	$default	reduce using rule 98 (compare_exp)

State 247:

	compare_exp -> compare_exp . L_EQ compare_exp	(Rule 98)
	compare_exp -> compare_exp . L_NE compare_exp	(Rule 99)
	compare_exp -> compare_exp . '<' compare_exp	(Rule 100)
	compare_exp -> compare_exp '<' compare_exp .	(Rule 100)
	compare_exp -> compare_exp . '>' compare_exp	(Rule 101)
	compare_exp -> compare_exp . L_LE compare_exp	(Rule 102)
	compare_exp -> compare_exp . L_GE compare_exp	(Rule 103)

	$default	reduce using rule 100 (compare_exp)

State 248:

	compare_exp -> compare_exp . L_EQ compare_exp	(Rule 98)
	compare_exp -> compare_exp . L_NE compare_exp	(Rule 99)
	compare_exp -> compare_exp . '<' compare_exp	(Rule 100)
	compare_exp -> compare_exp . '>' compare_exp	(Rule 101)
	compare_exp -> compare_exp '>' compare_exp .	(Rule 101)
	compare_exp -> compare_exp . L_LE compare_exp	(Rule 102)
	compare_exp -> compare_exp . L_GE compare_exp	(Rule 103)

	$default	reduce using rule 101 (compare_exp)

State 249:

	statement -> L_WHILE '(' nv_list_exp . ')' @5-4 statement	(Rule 34)

	')'	shift, and go to state 274

State 250:

	statement -> L_CASE exp ':' .	(Rule 44)

	$default	reduce using rule 44 (statement)

State 251:

	statement -> L_CASE exp L_RANGE . exp ':'	(Rule 45)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 275
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 252:

	arg_list -> arg_list ',' . exp	(Rule 61)
	opt_arg_list_comma -> arg_list ',' .	(Rule 66)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 66 (opt_arg_list_comma)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 276
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 253:

	array -> L_ARRAY_START opt_arg_list_comma L_ARRAY_END .	(Rule 171)

	$default	reduce using rule 171 (array)

State 254:

	basic_exp -> L_SSCANF '(' exp . lvalue_list ')'	(Rule 139)

	$default	reduce using rule 142 (lvalue_list)

	lvalue_list	go to state 277

State 255:

	statement -> L_IF '(' nv_list_exp . ')' statement opt_else	(Rule 29)

	')'	shift, and go to state 278

State 256:

	function_name -> L_EFUN L_COLONCOLON identifier .	(Rule 76)

	$default	reduce using rule 76 (function_name)

State 257:

	list_exp -> list_exp . ',' exp	(Rule 54)
	basic_exp -> L_CATCH '(' list_exp . ')'	(Rule 140)

	')'	shift, and go to state 279
	','	shift, and go to state 194

State 258:

	list_exp -> list_exp ',' exp .	(Rule 54)

	$default	reduce using rule 54 (list_exp)

State 259:

	closure -> L_FUNCTION_START list_exp L_FUNCTION_END .	(Rule 173)

	$default	reduce using rule 173 (closure)

State 260:

	statement -> L_TRY block L_CATCH . '(' lvalue ')' block	(Rule 40)

	'('	shift, and go to state 280

State 261:

	statement -> L_SWITCH '(' nv_list_exp . ')' @8-4 block	(Rule 43)

	')'	shift, and go to state 281

State 262:

	assoc_arg_list -> assoc_arg_list ',' assoc_exp .	(Rule 69)

	$default	reduce using rule 69 (assoc_arg_list)

State 263:

	assoc_exp -> exp ':' exp .	(Rule 67)

	$default	reduce using rule 67 (assoc_exp)

State 264:

	basic_exp -> '$' '(' identifier ')' .	(Rule 136)

	$default	reduce using rule 136 (basic_exp)

State 265:

	statement -> L_DO @3-1 statement @4-3 . L_WHILE '(' nv_list_exp ')' ';'	(Rule 32)

	L_WHILE	shift, and go to state 282

State 266:

	statement -> L_RLIMITS '(' nv_list_exp ';' . nv_list_exp ')' statement	(Rule 39)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 283
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 267:

	basic_exp -> function_name '(' opt_arg_list ')' .	(Rule 138)

	$default	reduce using rule 138 (basic_exp)

State 268:

	arg_list -> arg_list ',' . exp	(Rule 61)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 276
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 269:

	statement -> L_FOREACH '(' lvalue L_IN . exp ')' @7-6 statement	(Rule 38)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 284
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 270:

	basic_exp -> array_exp L_ARROW identifier '(' . opt_arg_list ')'	(Rule 141)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 62 (opt_arg_list)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	arg_list	go to state 218
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 181
	postfix_exp	go to state 109
	opt_arg_list	go to state 285
	function_name	go to state 80
	identifier	go to state 83

State 271:

	array_exp -> array_exp '[' opt_endrange nv_list_exp . ']'	(Rule 124)
	array_exp -> array_exp '[' opt_endrange nv_list_exp . L_RANGE opt_endrange nv_list_exp ']'	(Rule 125)

	']'	shift, and go to state 286
	L_RANGE	shift, and go to state 287

State 272:

	statement -> L_FOR '(' opt_list_exp ';' . opt_nv_list_exp ';' opt_list_exp ')' @6-8 statement	(Rule 36)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 58 (opt_nv_list_exp)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 142
	closure	go to state 104
	integer	go to state 105
	opt_nv_list_exp	go to state 288
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 273:

	cond_exp -> logical_exp '?' list_exp ':' . cond_exp	(Rule 90)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	arith_exp	go to state 67
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 150
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	postfix_exp	go to state 109
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 289

State 274:

	statement -> L_WHILE '(' nv_list_exp ')' . @5-4 statement	(Rule 34)

	$default	reduce using rule 33 (@5-4)

	@5-4	go to state 290

State 275:

	statement -> L_CASE exp L_RANGE exp . ':'	(Rule 45)

	':'	shift, and go to state 291

State 276:

	arg_list -> arg_list ',' exp .	(Rule 61)

	$default	reduce using rule 61 (arg_list)

State 277:

	basic_exp -> L_SSCANF '(' exp lvalue_list . ')'	(Rule 139)
	lvalue_list -> lvalue_list . ',' lvalue	(Rule 143)

	')'	shift, and go to state 293
	','	shift, and go to state 292

State 278:

	statement -> L_IF '(' nv_list_exp ')' . statement opt_else	(Rule 29)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 294
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 279:

	basic_exp -> L_CATCH '(' list_exp ')' .	(Rule 140)

	$default	reduce using rule 140 (basic_exp)

State 280:

	statement -> L_TRY block L_CATCH '(' . lvalue ')' block	(Rule 40)

	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	lvalue	go to state 295
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 220
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90

State 281:

	statement -> L_SWITCH '(' nv_list_exp ')' . @8-4 block	(Rule 43)

	$default	reduce using rule 42 (@8-4)

	@8-4	go to state 296

State 282:

	statement -> L_DO @3-1 statement @4-3 L_WHILE . '(' nv_list_exp ')' ';'	(Rule 32)

	'('	shift, and go to state 297

State 283:

	statement -> L_RLIMITS '(' nv_list_exp ';' nv_list_exp . ')' statement	(Rule 39)

	')'	shift, and go to state 298

State 284:

	statement -> L_FOREACH '(' lvalue L_IN exp . ')' @7-6 statement	(Rule 38)

	')'	shift, and go to state 299

State 285:

	basic_exp -> array_exp L_ARROW identifier '(' opt_arg_list . ')'	(Rule 141)

	')'	shift, and go to state 300

State 286:

	array_exp -> array_exp '[' opt_endrange nv_list_exp ']' .	(Rule 124)

	$default	reduce using rule 124 (array_exp)

State 287:

	array_exp -> array_exp '[' opt_endrange nv_list_exp L_RANGE . opt_endrange nv_list_exp ']'	(Rule 125)

	'<'	shift, and go to state 234

	$default	reduce using rule 126 (opt_endrange)

	opt_endrange	go to state 301

State 288:

	statement -> L_FOR '(' opt_list_exp ';' opt_nv_list_exp . ';' opt_list_exp ')' @6-8 statement	(Rule 36)

	';'	shift, and go to state 302

State 289:

	cond_exp -> logical_exp '?' list_exp ':' cond_exp .	(Rule 90)

	$default	reduce using rule 90 (cond_exp)

State 290:

	statement -> L_WHILE '(' nv_list_exp ')' @5-4 . statement	(Rule 34)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 303
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 291:

	statement -> L_CASE exp L_RANGE exp ':' .	(Rule 45)

	$default	reduce using rule 45 (statement)

State 292:

	lvalue_list -> lvalue_list ',' . lvalue	(Rule 143)

	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	string	go to state 75
	lvalue	go to state 304
	integer	go to state 105
	closure	go to state 104
	array_exp	go to state 220
	function_name	go to state 80
	basic_exp	go to state 70
	identifier	go to state 83
	array	go to state 101
	mapping	go to state 90

State 293:

	basic_exp -> L_SSCANF '(' exp lvalue_list ')' .	(Rule 139)

	$default	reduce using rule 139 (basic_exp)

State 294:

	statement -> L_IF '(' nv_list_exp ')' statement . opt_else	(Rule 29)

	L_ELSE	shift, and go to state 305

	$default	reduce using rule 51 (opt_else)

	opt_else	go to state 306

State 295:

	statement -> L_TRY block L_CATCH '(' lvalue . ')' block	(Rule 40)

	')'	shift, and go to state 307

State 296:

	statement -> L_SWITCH '(' nv_list_exp ')' @8-4 . block	(Rule 43)

	'{'	shift, and go to state 21

	block	go to state 308

State 297:

	statement -> L_DO @3-1 statement @4-3 L_WHILE '(' . nv_list_exp ')' ';'	(Rule 32)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 309
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 298:

	statement -> L_RLIMITS '(' nv_list_exp ';' nv_list_exp ')' . statement	(Rule 39)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 310
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 299:

	statement -> L_FOREACH '(' lvalue L_IN exp ')' . @7-6 statement	(Rule 38)

	$default	reduce using rule 37 (@7-6)

	@7-6	go to state 311

State 300:

	basic_exp -> array_exp L_ARROW identifier '(' opt_arg_list ')' .	(Rule 141)

	$default	reduce using rule 141 (basic_exp)

State 301:

	array_exp -> array_exp '[' opt_endrange nv_list_exp L_RANGE opt_endrange . nv_list_exp ']'	(Rule 125)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	nv_list_exp	go to state 312
	closure	go to state 104
	integer	go to state 105
	exp	go to state 143
	postfix_exp	go to state 109
	function_name	go to state 80
	identifier	go to state 83

State 302:

	statement -> L_FOR '(' opt_list_exp ';' opt_nv_list_exp ';' . opt_list_exp ')' @6-8 statement	(Rule 36)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_CATCH	shift, and go to state 124
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_DEC	shift, and go to state 112
	L_EFUN	shift, and go to state 103
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17

	$default	reduce using rule 55 (opt_list_exp)

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	opt_list_exp	go to state 313
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 236
	function_name	go to state 80
	identifier	go to state 83

State 303:

	statement -> L_WHILE '(' nv_list_exp ')' @5-4 statement .	(Rule 34)

	$default	reduce using rule 34 (statement)

State 304:

	lvalue_list -> lvalue_list ',' lvalue .	(Rule 143)

	$default	reduce using rule 143 (lvalue_list)

State 305:

	opt_else -> L_ELSE . statement	(Rule 52)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 314
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 306:

	statement -> L_IF '(' nv_list_exp ')' statement opt_else .	(Rule 29)

	$default	reduce using rule 29 (statement)

State 307:

	statement -> L_TRY block L_CATCH '(' lvalue ')' . block	(Rule 40)

	'{'	shift, and go to state 21

	block	go to state 315

State 308:

	statement -> L_SWITCH '(' nv_list_exp ')' @8-4 block .	(Rule 43)

	$default	reduce using rule 43 (statement)

State 309:

	statement -> L_DO @3-1 statement @4-3 L_WHILE '(' nv_list_exp . ')' ';'	(Rule 32)

	')'	shift, and go to state 316

State 310:

	statement -> L_RLIMITS '(' nv_list_exp ';' nv_list_exp ')' statement .	(Rule 39)

	$default	reduce using rule 39 (statement)

State 311:

	statement -> L_FOREACH '(' lvalue L_IN exp ')' @7-6 . statement	(Rule 38)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 317
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 312:

	array_exp -> array_exp '[' opt_endrange nv_list_exp L_RANGE opt_endrange nv_list_exp . ']'	(Rule 125)

	']'	shift, and go to state 318

State 313:

	statement -> L_FOR '(' opt_list_exp ';' opt_nv_list_exp ';' opt_list_exp . ')' @6-8 statement	(Rule 36)

	')'	shift, and go to state 319

State 314:

	opt_else -> L_ELSE statement .	(Rule 52)

	$default	reduce using rule 52 (opt_else)

State 315:

	statement -> L_TRY block L_CATCH '(' lvalue ')' block .	(Rule 40)

	$default	reduce using rule 40 (statement)

State 316:

	statement -> L_DO @3-1 statement @4-3 L_WHILE '(' nv_list_exp ')' . ';'	(Rule 32)

	';'	shift, and go to state 320

State 317:

	statement -> L_FOREACH '(' lvalue L_IN exp ')' @7-6 statement .	(Rule 38)

	$default	reduce using rule 38 (statement)

State 318:

	array_exp -> array_exp '[' opt_endrange nv_list_exp L_RANGE opt_endrange nv_list_exp ']' .	(Rule 125)

	$default	reduce using rule 125 (array_exp)

State 319:

	statement -> L_FOR '(' opt_list_exp ';' opt_nv_list_exp ';' opt_list_exp ')' . @6-8 statement	(Rule 36)

	$default	reduce using rule 35 (@6-8)

	@6-8	go to state 321

State 320:

	statement -> L_DO @3-1 statement @4-3 L_WHILE '(' nv_list_exp ')' ';' .	(Rule 32)

	$default	reduce using rule 32 (statement)

State 321:

	statement -> L_FOR '(' opt_list_exp ';' opt_nv_list_exp ';' opt_list_exp ')' @6-8 . statement	(Rule 36)

	'!'	shift, and go to state 88
	'$'	shift, and go to state 69
	'('	shift, and go to state 74
	'+'	shift, and go to state 106
	'-'	shift, and go to state 107
	';'	shift, and go to state 78
	'{'	shift, and go to state 21
	'~'	shift, and go to state 116
	L_ARRAY_START	shift, and go to state 97
	L_BREAK	shift, and go to state 99
	L_CASE	shift, and go to state 96
	L_CATCH	shift, and go to state 110
	L_CHARACTER	shift, and go to state 18
	L_COLONCOLON	shift, and go to state 86
	L_CONTINUE	shift, and go to state 84
	L_DEC	shift, and go to state 112
	L_DEFAULT	shift, and go to state 66
	L_DO	shift, and go to state 71
	L_EFUN	shift, and go to state 103
	L_FOR	shift, and go to state 91
	L_FOREACH	shift, and go to state 82
	L_FUNCTION_START	shift, and go to state 113
	L_HEXINTEGER	shift, and go to state 19
	L_IDENTIFIER	shift, and go to state 41
	L_IF	shift, and go to state 102
	L_INC	shift, and go to state 85
	L_INTEGER	shift, and go to state 15
	L_MAP_START	shift, and go to state 68
	L_NIL	shift, and go to state 98
	L_PARAMETER	shift, and go to state 114
	L_RETURN	shift, and go to state 76
	L_RLIMITS	shift, and go to state 79
	L_SSCANF	shift, and go to state 100
	L_STRING	shift, and go to state 17
	L_SWITCH	shift, and go to state 117
	L_TRY	shift, and go to state 115
	L_WHILE	shift, and go to state 95

	lvalue	go to state 87
	arith_exp	go to state 67
	array_exp	go to state 89
	mapping	go to state 90
	logical_exp	go to state 92
	compare_exp	go to state 93
	block	go to state 94
	basic_exp	go to state 70
	array	go to state 101
	prefix_exp	go to state 72
	cond_exp	go to state 73
	string	go to state 75
	closure	go to state 104
	integer	go to state 105
	statement	go to state 322
	exp	go to state 108
	postfix_exp	go to state 109
	list_exp	go to state 111
	function_name	go to state 80
	identifier	go to state 83

State 322:

	statement -> L_FOR '(' opt_list_exp ';' opt_nv_list_exp ';' opt_list_exp ')' @6-8 statement .	(Rule 36)

	$default	reduce using rule 36 (statement)


Summary:
--------
Number of rules         : 174
Number of terminals     : 87
Number of non-terminals : 64
Number of states        : 323
